<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[何为Vuex]]></title>
    <url>%2F2019%2F05%2F21%2Fvue-vuex%2F</url>
    <content type="text"><![CDATA[VuexVuex 是一个专为 Vue.js 应用程序开发的状态管理模式。 以一个全局单例管理组件的共享状态 通过定义和隔离状态管理中的各种概念并通过强制规则维持视图和状态间的独立性 特点： 单向数据流 什么情况下使用 VuexVuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。 应用简单，不推荐使用。 中大型单页应用推荐使用。 核心概念State单一状态树Vuex 使用单一状态树，一个对象包含全部的应用级状态（SSOT）。 在组件中获取 Vuex 状态Vuex 通过 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。 123456789101112131415161718192021// 子组件const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125;const app = new Vue(&#123; el: '#app', // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: &#123; Counter &#125;, template: ` &lt;div class="app"&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt; `&#125;) mapState 状态函数获取多个状态，声明多个计算属性出现重复和冗余。 mapState 可以辅助生成计算属性 123456789101112131415161718// 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 'count' 等同于 `state =&gt; state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;)&#125; 映射的计算属性和 state 的子节点名称相同时，可以给 mapState 传递字符串数组 1234computed: mapState([ // 映射 this.count 为 store.state.count 'count']) Getter从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数： Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) 通过属性访问1store.getters.doneTodos Getter 也可以接受其他 getter 作为第二个参数： 12345678getters: &#123; // ... doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125;&#125;// 使用store.getters.doneTodosCount // -&gt; 1 在任何组件中使用它： 12345computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125; 通过方法访问让 getter 返回一个函数，来实现给 getter 传参。 12345678getters: &#123; // ... getTodoById: (state) =&gt; (id) =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id) &#125;&#125;// 使用store.getters.getTodoById(2) // -&gt; &#123; id: 2, text: '...', done: false &#125; mapGetter 辅助函数mapGetter 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性： 12345678910111213import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125; getter 属性更改名字 1234mapGetters(&#123; // 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount` doneCount: 'doneTodosCount'&#125;) Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; // 变更状态 state.count++ &#125; &#125;&#125;) 提交载荷 （playload）12345678910111213141516mutations: &#123; increment (state, n) &#123; state.count += n &#125;&#125;store.commit('increment', 10)//大多数情况下，载荷应该是一个对象，可以包含对个记录字段mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125;store.commit('increment', &#123; amount: 10&#125;) 对象风格的提交方式1234store.commit(&#123; type: 'increment', amount: 10&#125;) Mutation 需遵守 Vue 的响应规则Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。 在 store 中提前初始化好所有所需属性。 当需要在对象上添加新属性时，有两种选择 使用 Vue.set(obj,&#39;key&#39;,&#39;value&#39;) 以新对象替换老对象 state.obj={...state.obj,key:value} Mutation 必须是同步函数在 Vuex 中，mutation 都是同步事务： 任何在回调函数中进行的状态的改变都是不可追踪的。 在组件中提交 Mutation this.$store.commit(xxx) 使用 mapMutations 将组件中的 methods 映射为 store.commit 12345678910111213141516import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` &#125;) &#125;&#125; ActionAciton 与 Mutation 类似 不同之处： Action 提交的是 mutation，而不是直接改变 state Action 可以包含异步操作 12345678910111213141516const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) context 与 store 实例具有相同的方法和属性，但不是store本身 contxt 提交 mutation context.commit contxt.state context.getters 12345actions: &#123; increment (&#123; commit &#125;) &#123; commit('increment') &#125;&#125; 分发 ActionAction 通过 store.dispatch 分发 在组件中分发 Action this.$store.dispatch(xxx) 使用 mapActions 将组件中的 methods 映射为 store.dispatch 组合 ActionAction 通常是异步的 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise： 1234567891011121314actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;&#125;store.dispatch('actionA').then(() =&gt; &#123; // ...&#125;) 在另一个 action 中也可以： 12345678actions: &#123; // ... actionB (&#123; dispatch, commit &#125;) &#123; return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;) &#125;&#125; 使用 async/await 1234567891011// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) &#125;&#125; ModuleVuex 允许我们将 store 分割成模块。 每个模块拥有自己的 state、mutation、action、getter。 123456789101112131415161718192021const moduleA = &#123; state:&#123;...&#125;, mutations:&#123;...&#125;, actions:&#123;...&#125;, getters:&#123;...&#125;,&#125;const moduleB = &#123; state:&#123;...&#125;, mutations:&#123;...&#125;, actions:&#123;...&#125;, getters:&#123;...&#125;,&#125;const store = new Vuex.Store(&#123; modules:&#123; a:moduleA, b:moduleB &#125;&#125;)store.state.a // moduleA 的状态store.state.b // moduleB 的状态 模块内部的具体分布 123456789101112131415161718192021const moduleA = &#123; state:&#123;count:0&#125;, mutations:&#123; increment(state)&#123; state.count++ &#125; &#125;, actions:&#123; //局部状态通过 context.state 暴露。根节点状态 contex.rootState incrementWithRootSum(&#123;state,commit,rootState&#125;)&#123; if((state.count + rootState.count)%2==1)&#123; commit('increment') &#125; &#125; &#125;, getters:&#123; sumWithRoot(state,getters,rootState)&#123; return state.count + rootState.count &#125; &#125;,&#125; 项目结构Vuex 需要遵守的规则： 应用层级的状态应该集中到单个 store 对象中 提交 mutation 是更改状态的唯一方法，并且这个过程是同步的。 异步逻辑都应该封装到 action 里 1234567891011121314├── index.html├── main.js├── api│ └── ... # 抽取出API请求├── components│ ├── App.vue│ └── ...└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── cart.js # 购物车模块 └── products.js # 产品模块]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发是什么?]]></title>
    <url>%2F2019%2F05%2F21%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[前端开发pc端，移动端 移动前端开发工程师，h5前端开发工程师，native前端开发工程师，Hybrid前端开发工程师 pc端 ie6-11，firefox，chrome，safari都得兼容css和js。 mobile端 webkit内核的浏览器和chrome，uc，qq，小米手机浏览器 移动端web app开发与 Hybrid 开发开发区别。移动端web app，移动端网页，Hybrid开发 移动端web app12345&lt;!-- meta的作用：让普通移动网页被添加到主屏幕后，拥有一些类native的功能。 ex: ios 隐藏上下状态栏，禁止弹性拖拽，修改顶部颜色，实现全屏等。--&gt;&lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; 另一种类型：手机taobao，手机美团，手机微博的网页版。 开发者把它们伪装成 web app 的交互体验。 普通移动端网页手机新浪网，手机腾讯新闻 Hybrid开发使用原生作为容器，web实现大部分功能。 Hybrid是半Native半web开发模式 成熟的Hybrid模式意味着业务逻辑均由H5实现 成熟的Hybrid模式可复用性非常高,可以跨平台开发 优点：资源是本地化的，所以可以使用比较重的框架，如angular，react，一些三方框架，因为最终都是通过和native代码捆绑发布的。 js 和 cssjs 的使用 少用框架，多手写。 移动端的优化瓶颈：网络加载速度不一致，有wifi，有3g，有4g，还有2g。 代码量在移动端开发是很大的一个考察点。 css 的使用 原生属性/特性的掌握 很多属性极限突破可以使用缩放，倾斜这种手段来hack，比如最小字体，比如各种自己画的伪类图标 能css画的不要用图。 大小需要自适应的图标做成字体的不要画。 能flex布局的不要用浮动，不要用绝对定位（不利于页面布局的扩展）]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[面试]-浏览器相关]]></title>
    <url>%2F2019%2F05%2F19%2F%E9%9D%A2%E8%AF%95-brower%2F</url>
    <content type="text"><![CDATA[浏览器事件机制事件触发三阶段DOM2级事件规定的事件流包括三个阶段：事件的捕获阶段、处于目标阶段和事件冒泡阶段。 事件的捕获阶段：window往事件触发处传播，遇到注册的捕获事件会触发。 目标阶段：传播到事件触发处时触发注册的事件 冒泡阶段：从事件触发往window传播 事件触发一般会按照这三个阶段顺序执行。但也有特例，如果给一个目标节点同时注册冒泡和捕获事件，会按照事件注册的顺序执行 12node.addEventListener('click',e=&gt;console.log('冒泡'),false)node.addEventListener('click',e=&gt;console.log('捕获'),true) 注册事件EventTarget.addEventListener() 方法将指定的监听器注册到 EventTarget 上，当该对象触发指定的事件时，指定的回调函数就会被执行。 事件目标可以是一个文档上的元素 Element,Document和Window或者任何其他支持事件的对象 (比如 XMLHttpRequest)。 addEventListener()的工作原理是将实现EventListener的函数或对象添加到调用它的EventTarget上的指定事件类型的事件侦听器列表中。 语法： target.addEventListener(type, listener[, options]);target.addEventListener(type, listener[, useCapture]); 参数： type: 监听事件类型的字符创 listener：当所监听的事件类型触发时，会接收到一个事件通知 options：一个有关listener属性的可选参数对象 capture once：Boolean，为true时，表示listener添加后只调用一次，调用完会清除listener passive：Boolean，为true时，表示listener不会调用preventDefault() useCapture：Boolean，该类型事件捕获阶段传递到目标时触发 事件代理如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上。 12let ul = document.querySelector('#ul')ul.addEventListener('click', e =&gt; console.log(e.target)) 优点 节省内存 不需要给子节点注销事件 跨域浏览器出于安全考虑，有同源策略。所谓同源，就是同个协议，同个域名，同个端口。若不是同源，AJAX请求会失败。 解决方案 JSOPJSONP利用&lt;script&gt;标签没有跨域限制的漏洞。通过&lt;srcipt&gt;标签指向一个目的地址并提供一个回调函数来接收数据。 JSONP仅限于get请求 1234567&lt;script src="http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"&gt;&lt;/script&gt;&lt;script&gt; function jsonp(data) &#123; console.log(data) &#125;&lt;/script&gt; CORSCORS需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest来实现。 浏览器会自动进行CORS通信，实现CORS关键在与后端。只要后端实现了CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 document.domain该方式只能用于二级域名相同的情况下。 a.test.com和b.test.com使用于该方式。 只需要给页面添加 document.domain = &#39;test.com&#39; postMessage这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息 12345678910//发送消息端window.parent.postMessage('message','http://test.com')//接收消息端var mc = new MessageChannel()mc.addEventListener('message',e=&gt;&#123; var origin = e.origin || e.originalEvent.origin if(origin === 'http://test.com')&#123; console.log('pass') &#125;&#125;) Event loopJS在执行过程中会产生执行环境，这些执行环境会被顺序加入到执行栈中。如果遇到异步的代码，会被挂起并加入到Task（有多种task）队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上JS的异步还是同步行为。 12345console.log(`script start`)setTimeout(()=&gt;console.log('setTimeout'),0) // HTML5规定，至少为4ms，因此还是属于异步。console.log(`script end`)// script start -&gt; script end -&gt; setTimeout 不同的任务源会被分配到不同的Task队列中，任务源（microtask）和宏任务（marcrotask）。 ES6规范中，microtask称为jobs，macrotask称为task。 12 微任务：process.nextTick，promise，Object.observe，MutationObserver 宏任务：script，setTimeout，setInterval，setImmediate，I/O，UI rendering 宏任务包括了script，浏览器会先执行一个宏任务，接下来有异步代码的话就执行微任务。 Event loop 执行顺序 执行同步代码，属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所以微任务 必要的话渲染 UI 开始下一轮 Event loop，执行宏任务中的异步代码 因此，若宏任务中的异步代码有大量计算并且需要操作DOM，为了更好的界面响应，可以把操作DOM放入微任务中。 Node中的 Event loopNode 的 Event loop 分为6个阶段 timers I/O callbacks idle , prepare poll check close callbacks 存储cookie，localStorage，sessionStorage，indexDB 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4k 5M 5M 无限 与服务端通信 每次都会携带在header中，对于请求性能影响 不参与 不参与 不参与 Service Worker Srivice Worker 本质上充当 Web 应用程序和浏览器之间的代理服务器，也可以在网络可用时，作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步 API。 Service Worker 可以使你的应用先访问本地缓存资源，所以在离线状态时，在没有通过网络接收到更多的数据前，仍可以提供基本的功能（一般称之为 Offline First）。这是原生APP 本来就支持的功能，这也是相比于 web app，原生 app 更受青睐的主要原因。 Service Worker 通常用来做缓存文件，提高首屏速度。 渲染机制浏览器渲染机制的步骤： 处理HTML并构建DOM树 处理CSS并构建CSSDOM树 合并DOM树和CSSDOM树为一颗渲染树 根据渲染树布局，计算节点位置 调用GPU绘制，合成图层，显示在屏幕上 在构建CSSDOM时，会阻塞渲染，直至CSSDOM树完成。构建CSSDOM十分消耗性能，所以应该保证层级扁平，减少过度层叠。 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。 script影响DOM构建，CSS影响script执行-&gt; CSS影响DOM构建 Load 和 DOMContentLoaded 区别Load触发，代表全部资源加载完毕。 DOMContentLoaded表示初始的HTML被完全加载解析。 图层普通文档流可视为一个图层。特定的属性可以生成一个新的图层。不同图层的渲染互不影响，某些需要频繁渲染的建议单独生成一个新图层，提高性能。 常用的生成新图层的属性： 3D变换：translate3d、translateZ will-change video iframe 标签 通过动画实现的opacity动画转换 postion:fixed 重绘（Repaint）和回流（Reflow） 重绘：当需要改变节点外观不影响布局 回流：布局或者集合属性需要改变 回流必重绘，重绘不一定回流。 以下几个动作可能导致性能问题： 改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 重绘与回流与 Event loop 有关 减少重绘和回流 使用translate代替top 使用visibility替换display:none（前者重绘，后者回流） DOM离线后修改。（先display:none，一次reflow），修改满意后，再显示出来。 不要在循环中遍历DOM属性值 不要用table布局，小改动容易影响整个布局 动画实现的速度的选择，动画速度越快，回流次数越多 CSS选择符从右往左匹配查找（从左到右会出现回溯的情况） 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层。]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[面试]-JS相关]]></title>
    <url>%2F2019%2F05%2F11%2F%E9%9D%A2%E8%AF%95-js%2F</url>
    <content type="text"><![CDATA[JStypeof 基本类型 除了null都可以显示正确的类型 1typeof null //object JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 对象 除了函数都会显示object 1typeof console.log //function Object.prototype.toString.call()获得变量的正确类型[object Type] undefined不是保留字，在低版本可以被赋值。因此不适合作为比较，使用void 0返回的undefined可以满足要求 类型转化 转Boolean 条件判断时，除了undefined,null,false,NaN,&#39;&#39;,0,-0，其它都转为true，包括所有对象。 对象转基本类型 调用优先级：Symbol.toPrimitive , valueOf , toString 12345678910111213let a = &#123; valueOf()&#123; return 0; &#125; toString()&#123; return '1'; &#125; [Symbol.toPrimitive]()&#123; return 2; &#125;&#125;1 + a // =&gt; 3'1' + a // =&gt; '12' 四则运算符 加法的执行：将值转为原始值-&gt;转化为数字-&gt;转化为字符串 1234567891 + '1' // '11'2 * '2' // 4[1,2] + [2,1] // '1,22,1'[1,2].toString() // -&gt; '1,2''1,2' + '2,1' // '1,22,1''a' + + 'b' // -&gt; 'aNaN'// + 'b' -&gt; NaN// + '1' -&gt; 1 ==操作符 1[] == ![] // -&gt; true 比较运算符 如果是对象。通过toPrimitive转化对象 如果是字符串。通过unicode字符索引比较 原型 每个函数都有函数都有prototype属性，除了Function.prototype.bind()，该属性指向原型。 每个对象都有__proto__属性，指向了创建该对象的构造函数逇原型。 对象可以通过__proto__来寻找不属于该对象的属性，__proto__将对象连接组成了原型链。 new 新生成一个对象 链接到原型 绑定this 返回新对象 instanceofinstanceof可以正确判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的prototype。 this this依赖于调用函数前的对象 1234567891011function foo()&#123; console.log(this.a);&#125;var a = 1;foo()var obj = &#123; a:2, foo:foo&#125;obj.foo(); 使用new优先级最高，this只会绑定在创建的对象c上 123var c = new foo()c.a = 3console.log(c.a) 利用call , apply , bind改变this，优先级仅次于new 箭头函数的this只取决于外部非箭头函数的this 执行上下文 全局执行上下文 函数执行上下文 eval执行上下文 每个执行上下文都有三个重要属性： 变量对象 作用域链（js采用词法作用域，变量定义时就可确定作用域） this 关于 var在生成执行上下文的时候，有两个阶段。第一阶段是创建阶段，JS解释器会找出需要提升的变量和函数，并且给他们提前开辟空间，函数整个会存入内存，变量只声明且赋值为undefined。第二阶段，代码执行阶段，我们可以提前使用。 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升 关于 letES6中引入了let，let也有提升声明但是没有赋值。 非匿名立即执行函数123456var foo = 1(function foo()&#123; foo = 10 console.log(foo)&#125;())// -&gt; ƒ foo() &#123; foo = 10 ; console.log(foo)&#125; [Function: foo] JS在遇到非匿名立即执行函数时，会创建一个特定的辅助对象，然后将函数名作为特定对象的属性，因此函数内部才可以访问到foo，但是该值是只读的，所以对它的赋值并不生效。 闭包 函数A返回函数B，并且函数B使用到了A的变量，函数B称为闭包。 为什么函数A已经出栈，函数B还可以使用到它的变量呢，因为JS引擎可以通过逃逸分析确定哪些变量需要存储在堆上，哪些存储在栈上。 经典面试题123456for(var i=1; i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i) &#125;,i*1000)&#125;// -&gt; 输出结果都为6，因为setTimeout是异步函数，循环结束后再执行。 解决方案： 闭包 1234567for(var i=0;i&lt;=5;i++)&#123; (function(j)&#123; setTimeout(function timer()&#123; console.log(j) &#125;,i*1000) &#125;)(i);&#125; setTimeout的第三个参数 12345for(var i=1; i&lt;=5;i++)&#123; setTimeout(function timer(j)&#123; console.log(j) &#125;,i*1000,i)&#125; let定义 123456// let会创建块级作用域，把每次新的i值创建一个副本保留在每个作用域中。for(let i=0;i&lt;=5;i++)&#123; setTimeout(function timer()&#123; console.log(i) &#125;,i*1000)&#125; 深浅拷贝在开发中，我们给一个变量赋值一个对象，两者的值会是同一个引用，一方修改，另一方跟着修改。 浅拷贝 Object.assign可以解决上述问题 123456let a = &#123; age : 1&#125;let b = Object.assign(&#123;&#125;,a)a.age = 2console.log(b.age) // 1 拓展运算符... 123456let a = &#123; age : 1&#125;let b = &#123;...a&#125;a.age = 2console.log(b.age) // 1 注意：浅拷贝只能解决第一层，若有嵌套对象的话，则依然会享有共同的引用。此时就需要深拷贝。 深拷贝解决方案： JSON.parse(JSON.stringify(object))局限性： 忽略undefined , symbol 不能序列化函数 不能解决循环引用的对象 MessageChannel拷贝的对象含有内置类型并且不包含函数lodash深拷贝模块化 ES6模块化 123456789// file a.jsexport function a()&#123;&#125;export function b()&#123;&#125;// file b.jsexport default function()&#123;&#125;import &#123;a,b&#125; form './a.js'import xxx form './b.js' CommonJS Node独有规范，浏览器使用需要Browerify解析 1234567891011// a.jsmodule.exports = &#123; a:1&#125;//orexports.a = 1//两者用法相似，只是不能对exports直接赋值// b.jsvar module = require('./a.js');module.a // 1 CommonJS 和 ES6 模块化的区别 前者支持动态导入，require(${path}/xx.js)，后者暂不支持 前者是同步导入，作用于服务器。后者是异步导入，作用于浏览器。 前者导出是值拷贝。后者是实时绑定。 AMD RequireJS提出的规范 防抖防抖动是将多次执行变为最后一次执行。 节流节流是将多次执行变成每隔一段时间执行。 继承ES5 Object.create(proto, [propertiesObject]) 参数： proto 新创建对象的原型对象 propertiesObject 可选。如果没有指定为 undefined，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应Object.defineProperties()的第二个参数。 返回值 一个新对象，带着指定的原型对象和属性。 12345678910111213141516//将子类的原型设置为父类的原型function Super()&#123;&#125;Super.prototype.getNumber = function()&#123; return 1;&#125;function Sub()&#123;&#125;Sub.prototype = Object.create(Super.prototype,&#123; constructor: &#123; value: Sub, enumerable: false, writable: true, configurable: true &#125;&#125;);var sub = new SuB(); ES612345678910111213class Foo &#123; static classMethod() &#123; return 'hello'; &#125;&#125;class Bar extends Foo &#123; static classMethod() &#123; return super.classMethod() + ', too'; &#125;&#125;Bar.classMethod() // "hello, too" call,apply,bind区别 call和apply都是为了改变this的指向。作用相同，传参方式不同。 call和apply第一个参数都是调用者this，不传参则默认为window。 除第一个参数外，call可以接收一个参数列表，apply只接收一个参数数组。 模拟与实现call和apply 不传第一个参数，默认为window 改变this指向，新对象执行该函数。=&gt; 给新对象添加一个函数，执行后删除。 1234567891011Function.prototype.myCall = function(context)&#123; var context = context || window //给 context 添加一个属性 context.fn = this // 将 context 后面的参数取出来 var args = [...arguments].slice(1) var result = context.fn(...args) //删除 fn delete context.fn return result&#125; bind也是改变指向，只是返回的是一个函数。我们可以通过bind实现1234567891011121314Function.prototype.myBind = function(context)&#123; if(typeof this !== 'function')&#123; throw new TypeError('Error') &#125; var _this = this var args = [...arguments].slice(1) //返回一个函数 return function F()&#123; if(this instanceof F)&#123; return new _this(...args,...arguments) &#125; return _this.apply(context,args.concat(...arguments)) &#125;&#125; Promise Promise是一个简单容器，存放着未来某个才会结束的世界的结果。 Promise对象特点 对象状态不受外界影响。 Promise对象表示一个异步操作，有三种状态。pending(进行中)、fulfilled(已成功)和rejected(已失败)。只有异步操作的结果可以确定当前是哪一种状态。 状态一旦改变，就不会再变。 pending-&gt;fulfilled pending-&gt;rejected 如果改变已经发生了，再对Promise对象添加回调函数，也会立即得到这个结果。 通常，我们会将resolved指定为fulfilled状态 Promise对象缺点 无法取消，一旦新建，立即执行 不设置回调函数，错误只会抛在内部 当处于pending时，无法得知进展到什么情况 基本用法Promise接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345678function timeout(ms)&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(resolve,ms,'done') &#125;)&#125;timeout(100).then(value=&gt; console.log(value)).catch(err =&gt; console.log(err)) 一般使用Promise.prototype.catch()，而不在then中指定reject Generator 语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 形式上，Generator 函数是一个普通函数，但是有两个特征。 function关键字与函数名之间有一个星号 函数体内部使用yield表达式，定义不同的内部状态 123456789101112// 使用 * 表示这是一个Generator函数// 使用 yield 暂停代码// 调用 next 恢复执行function* test()&#123; let a = 1 + 2 yield 2 yield 3&#125;let b = test()console.log(b.next())console.log(b.next())console.log(b.next()) Map、FlatMap、Reducemap的作用是生成一个新数组，通过遍历原数组，对每一个元素进行变换后append到新数组 Array.prototype.map123var new_array = arr.map(function callback(currentValue[, index[, array]]) &#123; // Return element for new_array&#125;[, thisArg]) callback 当前元素值 对应索引 被调用的数组 thisArg 执行callback时的使用的this 示例代码 1[1,2,3].map(v =&gt; v+1) Array.prototype.flatMapflatMap与map作用一致，只是会把数组扁平化。 1[1,[2],3].faltMap(v = &gt; v +1) Array.prototype.reduce1arr.reduce(callback[, initialValue]) callback accumulator 累计回调的返回值 currentVaule 正在处理的元素 currentIndex (可选) array (可选) 原数组 initialValue 作为调用callback函数时的第一个参数值，如果没有提供，则使用数组的第一个元素。 返回值： 累计的结果 示例代码： 1var sum = [0,1,2,3].reduce((acc,v)=&gt; acc+v) async和await一个函数加上async，那么该函数返回一个Promise，其实本质上是Generator的语法糖 1234async function test()&#123; return 1&#125;console.log(test()) // Promise &#123; '1' &#125; await只能在async函数中使用，遇到await会立即返回一个pending状态的Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 12345678910111213function sleep()&#123; return new Promise(resolve =&gt; &#123; setTimeout(()=&gt;&#123; console.log('finish') resolve('sleep') &#125;) &#125;)&#125;async function test()&#123; let value = await sleep() console.log('object')&#125;test() 以上会先打印finish，再打印object。因为 await 会等待 sleep 函数 resolve ，所以即使后面是同步代码，也不会先去执行同步代码再来执行异步代码 ProxyES6中的功能，用来自定义对象中的操作。 Proxy可以理解成为一个目标对象的拦截器，因此提供了一种机制，可以的外界的访问进行过滤或改写。 1var proxy = new Proxy(target,handler) 参数： target 要拦截的对象 handler 定义拦截行为，也是一个对象 示例代码： 1234567891011121314let handler = &#123; get: function(target, name)&#123; return name in target ? target[name] : 37; &#125;&#125;;let p = new Proxy(&#123;&#125;, handler);p.a = 1;p.b = undefined;console.log(p.a, p.b); // 1, undefinedconsole.log('c' in p, p.c); // false, 37 0.1+0.2!=0.3JS采用 IEEE 754 双精度版本， 这是该版本伴随的问题。 0.10的二进制表示为： 1234// (0011)表循环0.1 = 2^-4*1.10011(0011)0.2 = 2^-3 * 1.10011(0011) IEEE 754 双精度。六十四位中除去一位符号位整数占11位，小数占五十二位。0.1和0.2都是无限循环小数，所以小数末尾处需判断是否进位。 122^-4 * 1.10011...001 =&gt; 2^-4 * 1.10011(0011 * 12次)0102^-3 * 1.10011...001 =&gt; 2^-4 * 1.10011(0011 * 12次)010 相加结果：2^-2 * 1.0011(0011 * 11次)0100 折合成十进制：0.30000000000000004 原生JS解决方法1parseFloat((0.1 + 0.2).toFixed(10)) 正则表达式元字符 . 匹配任意字符，除换行符和回车符 [] 匹配方括号内的任意字符 ^ {1,2}匹配1-2位字符 (sc) 只匹配和sc相同字符串 | 匹配 | 前后字符 \ * + ? 修饰语 i g m 字符简写 \w 数字字母或下划线 \W 与上面相反 \s 任意空白符 \S \d 数字 \D \b 单词的边界 \B Chrome V8 下的垃圾回收机制自动垃圾回收有很多算法，由于不同对象的生存周期不同，所以无法只用一种回收策略来解决问题，这样效率会很低。 V8 采用了一种代回收策略，将内存分为和两个生代：新生代和老生代 新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象，分别对新老生代采用不同的垃圾回收算法来提高效率，对象最开始都会先被分配到新生代（如果新生代内存空间不够，直接分配到老生代），新生代中的对象会在满足某些条件后，被移动到老生代，这个过程也叫晋升 新生代算法新生代采用Scavenge垃圾回收算法，在算法实现时主要采用Cheney算法。 Cheney算法将内存一分为二，叫做semispace，一块处于使用状态（From空间），一块处于闲置状态（To空间）。 算法流程From空间存放活跃对象，判断活跃对象是否有引用，没有的话，回收，有的话将其复制到To空间，清空From空间全部内存，再交换From空间和To空间。并在From空间开始新的分配回收。 典型的牺牲空间换时间算法，但是恰好适合应用于新生代。 晋升当对象多次复制仍存活，视为长生命周期对象。需要移到老生代中管理。 晋升的条件 如果一个对象第二次经历从From到To，则会移到老生代。 From复制到To时，若To使用超过25%，则该对象直接晋升到老生代。因为完成回收后，To会变成From，进行新的内存分配，如果占比过高，会影响分配。 老生代V8在老生代中主要采用了Mark-Sweep和Mark-Compact相结合的方式进行垃圾回收。 Mark-SweepMark-Sweep是标记清除的意思，它分为标记和清除两个阶段。 算法过程 统一标记 去掉运行和被引用变量的标记 仍有标记的为待删除标记 GC完成清除，并回收空间 但是这个过程会出现内存碎片问题，对后续分配造成影响。 如果出现需要分配一个大内存，而剩余碎片空间不足分配，则会提前触发不必要的GC Mark-Compact为了解决Mark-Sweep的内存碎片问题而出现Mark-Compact Mark-Compact是标记整理的意思，Mark-Compact在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。 两者结合在V8的回收策略中，Mark-Sweep和Mark-Conpact两者是结合使用的。 由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。]]></content>
      <tags>
        <tag>JS</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[小程序]-map组件的使用]]></title>
    <url>%2F2019%2F04%2F28%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F-map%2F</url>
    <content type="text"><![CDATA[小程序实现周边美食展示map组件map常用属性 longitude 经度 laitude 纬度 scale 缩放级别：5~18 markers Array.&lt;marker&gt; 标记点 polyline Array.&lt;polyline&gt; 路线 show-location 显示带有方向的当前定位点 bindregionchange 视野发现变化时出发 bindmarkertap 点击标记点时触发，会返回marker的id map使用注意事项： map组件默认层级最高，并且不能设置。 请勿在 scroll-view 中使用 map 组件 css 动画对 map 组件无效。 map上显示其它组件的方法 设置controls属性（即将废弃，不推荐） 1234567891011controls: [&#123; id: 1, iconPath: '../../images/icon_cate.png', position: &#123; left: 0, top: 250, width: 50, height: 50 &#125;, clickable: true&#125;] 使用cover-view 组件 map代码实例123456789&lt;map id="myMap" show-location="true" style="width: 100%; height:&#123;&#123;height&#125;&#125;px; " longitude="&#123;&#123;x&#125;&#125;" latitude="&#123;&#123;y&#125;&#125;" scale="17" controls="&#123;&#123;controls&#125;&#125;" bindcontroltap="code" bindupdated="show"&gt; &lt;cover-view class='btn' bindtap='codeg'&gt; &lt;cover-image src='xxx.png' class='code'&gt;&lt;/cover-image&gt; &lt;cover-view class='text'&gt;立即购买&lt;/cover-view&gt; &lt;/cover-view&gt;&lt;/map&gt; cover-view： VM5041:5 &lt;cover-view/&gt; 内只能嵌套 &lt;cover-view/&gt; &lt;cover-image/&gt; &lt;button/&gt; &lt;navigator/&gt; &lt;ad/&gt;,其它组件在真机上会被忽略 map使用中的问题marker数组中设置callout气泡123456789callout: &#123; content: res.data[i].title, color: "#2c8df6", fontSize: 16, borderRadius: 10, bgColor: "#ffffff", //color&amp;bgColor都是用6位数字 display: "ALWAYS", boxShadow: "2px 2px 10px #aaa"&#125; 如何设置地图全屏显示（默认满屏为100vh）1234.myMap&#123; width:100%; height:100vh;&#125; 将地图中心点移动到当前位置123456789onReady: function(e) &#123; // 使用 wx.createMapContext 获取 map 上下文 this.mapCtx = wx.createMapContext('map')&#125;, // 将地图中心移动到当前位置moveToLocation: function() &#123; this.mapCtx.moveToLocation()&#125;, 滑动地图，动态获取地图中心点位置12345678var that = this;this.mapCtx.getCenterLocation(&#123; success(res) &#123; that.data.latitude = res.latitude; that.data.longitude = res.longitude; that.data.start = res.latitude + "," + res.longitude; &#125;&#125;) 根据关键词，获取指定周边123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869qmapsdk = new QQMapWX(&#123; key: 'VDJBZ-HKGWI-2D3GL-5YBEH-UCG4O-NTFH5'&#125;);qmapsdk.search(&#123; keyword: '美食', //搜索关键词 location: _this.data.start, //设置周边搜索中心点 success: function (res) &#123; //搜索成功后的回调 var mks = []; for (var i = 0; i &lt; res.data.length; i++) &#123; mks.push(&#123; // 获取返回结果，放到mks数组中 title: res.data[i].title, id: res.data[i].id, latitude: res.data[i].location.lat, longitude: res.data[i].location.lng, iconPath: 'http://www.daigua.com/wxmap/images/marker.png', //图标路径 width: 20, height: 20, callout: &#123; content: res.data[i].title, color: "#2c8df6", fontSize: 16, borderRadius: 10, bgColor: "#ffffff", display: "ALWAYS", boxShadow: "2px 2px 10px #aaa" &#125;, label: &#123; color: "#000", fontSize: 12, content: res.data[i].address, x: res.data[i].location.lng, y: res.data[i].location.lat &#125; &#125;)&#125;`### 更新坐标时候的问题地图marker的坐标如果想通过JS修改，光修改绑定坐标数据是无效的，必须通过小程序的地图组件控制接口wx.createMapContext，用translateMarker方法修改标记坐标才行+ 真机测试的时候，``polyline``显示不了的问题### 给map地图添加input输入框&gt; 真机上，原生组件map层级最高，暂时不支持``cover-input``。但是input框的焦点能够获取，因此我们可以通过覆盖一个相同大小的``cover-view``，把输入的文字重新绑定给``cover-view``显示出来。## 引申+ 计算两个点之间的距离```jsvar EARTH_RADIUS = 6378.137; //地球半径function rad(d) &#123; return d * Math.PI / 180.0;&#125;function getDistance(lng1, lat1, lng2, lat2) &#123; var radLat1 = rad(lat1); var radLat2 = rad(lat2); var a = radLat1 - radLat2; var b = rad(lng1) - rad(lng2); var s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) + Math.cos(radLat1) * Math.cos(radLat2) * Math.pow(Math.sin(b / 2), 2))); s = s * EARTH_RADIUS; s = Math.round(s * 10000) / 10000; return s;//返回数值单位：公里&#125; 获取商家手机号码，并打开手机拨打界面 123456wx.makePhoneCall(&#123; phoneNumber: '15218966603', success: function () &#123; console.log("成功拨打电话") &#125;&#125;) 获取路线轨迹（polyline的使用） 123456789101112polyline: [&#123; points: [ &#123;latitude: 23.129,longitude: 113.064&#125;, &#123;latitude: 23.26437,longitude: 113.129&#125; ], color: "#ff6600", width: 6, dottedLine: true, arrowLine: true, borderColor: "#000", borderWidth: 5&#125;]]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[JS]-单线程及异步]]></title>
    <url>%2F2019%2F04%2F23%2Fjs-%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%8F%8A%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[JS的主线程及执行栈前言 JS是一门单线程语言，那为何能够实现异步操作呢？ 单线程和异步操作确实不能同时成为一个语言的特性。JS本身不能实现异步，但是JS的宿主环境（浏览器，Node）是多线程的，宿主环境通过某种方式，使得JS具备了异步的特性。 浏览器JS是单线程语言，浏览器只分配给JS一个主线程，用来执行任务（函数），但一次只能执行一个任务，这些任务形成一个任务队列排队等候执行，但前端的某些任务是非常耗时的，比如网络请求，定时器和事件监听，如果让他们和别的任务一样，都老老实实的排队等待执行的话，执行效率会非常的低，甚至导致页面的假死。 浏览器为这些耗时任务开辟了另外的线程，主要包括http请求线程，浏览器定时触发器，浏览器事件触发线程，这些任务是异步的。 任务队列浏览器为这些异步任务单独开了一个线程，那么主线程是如何知道异步任务是否已经完成呢？这就需要依赖回调函数了，整个程序是靠事件驱动的，每个事件都有相应的回调函数。 123setTimeout(function()&#123; console.log('time up);&#125;,50) 主线程 JS一直在做一个工作，就是从任务队列里提取任务，放到主线程里执行。 浏览器为异步任务开启的线程序=&gt;WebAPIs 任务队列=&gt;callback queue 主线程 堆和栈 函数的执行就是通过进栈和出栈实现 栈stack清空时，说明一个任务已经执行完成，这时会从callback queue中寻找下一个任务推入栈中 容易困惑的问题setTimeout(f1,0)是否立即执行123456setTimeout(()=&gt;&#123; console.log(1)&#125;,0)console.log(2)// output =&gt; 2,1 当执行setTimeout后，浏览器会立即把匿名函数放入callback queue中，等待主线程的召唤，因为此时的stack还有console.log(2)尚未执行。等console.log(2)执行完毕后，才通过event loop把匿名函数放到stack中执行。 结论： setTimeout(f1,0)并非无意义，若f1是比较耗时的任务，又不在WebAPIs中，那就可以把它放到callback queue，等待主线程执行完毕后再执行。 若当前代码执行时间很长，没有办法保证回调函数一定会在setTimeout指定的时间内完成。 补充说明： HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。 DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout() 浏览器异步机制的使用 当我们自己需要写的程序中也有比较耗时的函数。可以通过浏览器提供给我们的浏览器定时事件和事件触发线程。 异步的好处和使用场景 异步的好处 同步执行 异步执行 使用场景 程序需要大量I/O操作和用户请求时]]></content>
  </entry>
  <entry>
    <title><![CDATA[[webpack]-基础知识及配置]]></title>
    <url>%2F2019%2F04%2F17%2Fwebpack-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[webpack 4.x的使用 需要安装 webpack webpack-cli 基本使用 webpack a.js -o b.js webpack.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172module.exports = &#123; devServer: &#123; port: 3000, progress: true, contentBase: './dist', //默认打开哪个目录 compress: true open:true &#125;, entry: path.join(__dirname, "./src/main.js"), output: &#123; path: path.join(__dirname, "./dist"), filename: 'bundle.js' &#125;, mode: 'development', // 'produciton' plugins: [ //放置所有插件 new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'index.html' &#125;) ], module: &#123; //解析文件的loader，使用loader解析更高级的语法和其他语言特性 rules: [ &#123; test: /\.js$/, use: &#123; loader: 'babel-loader', options: &#123; presets: [ '@babel/preset-env' ], plugins: [ ["@babel/plugin-proposal-decorators", &#123; "legacy": true &#125;], ["@babel/plugin-proposal-class-properties", &#123; "loose": true &#125;], ["@babel/plugin-transform-runtime"] ] &#125; &#125;, exclude: /node_modules/, //规定不解析该目录下的js文件 include: path.resolve(__dirname, 'src') &#125;, &#123; test: /\.css$/, use: [ 'css-loader', //'postcss-loader' ] &#125;, &#123; test: /\.less$/, use: [ 'css-loader', 'less-loader' ] &#125; ] &#125;, optimization: &#123; minimizer: [ new OptimizeCss(), new UgliyfyJsPlugin(&#123; cache: true, parallel: true, //并行压缩 sourceMap: true //源码映射 &#125;) ] &#125;&#125; package.json 配置运行的脚本命令，使用npm run dev执行对应命令 1234"scripts":&#123; "build": "webpack --config webpack.config.js", "dev": "webpack-dev-server"&#125; webpack中常用插件 打包html模板 html-webpack-plugin 解析文件的loader 解析css,style,less等 给css增加浏览器的前缀 postcss-loader，需要配置postcss.config.js 解析高级js语法的babel-loader，还需要@babel/core,@babel/preset-env等 代码校验： eslint-loader 解析css中出现的url：url-loader，file-loader 压缩css文件 optimize-css-assets-webpack-plugin 使用之后js便不会压缩，需要安装uglifyjs-webpack-plugin 源码映射 source-map 实时打包 watch 其他插件 clean-webpack-plugin 每次build的时候，重置dist copy-webpack-plugin 复制一些其他类型的文件到dist，txt等 banner-plugin 版权声明，再生成的js文件中添加自定义版权信息]]></content>
      <tags>
        <tag>wenpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios]]></title>
    <url>%2F2019%2F04%2F10%2Fvue-axios%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[同源策略,跨域解决]]></title>
    <url>%2F2019%2F04%2F07%2F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[浏览器同源策略,及跨域资源的解决方法同源策略 源: 服务器 同源 =&gt; 域名,协议,端口 一致 同源策略分类 DOM同源策略: 禁止对不同源页面进行DOM操作 XMLHttpRequest同源策略 : 禁止xhr对象向不同源服务器发起http请求. 跨域的解决方法CORS跨域 CORS [ Cross-origin resource sharing ], 定义在跨域时,浏览器和服务器应该如何沟通, 通过自定义的Http, 决定请求响应是否成功. 只要服务器实现CROS接口, 就可以跨域通信. CORS分类 简单请求 请求方法: HEAD GET POST 请求字段: Accept Accept-Language Content-Language Last-Event-ID Content-Type: application/x-www-form-urlencoded, multipart/form-data, text/plain 非简单请求 JSONP跨域 因为浏览器的安全性限制, 不允许ajax进行跨域(不同域名/不同端口/不同协议…)访问 通过动态创建script标签, 实现跨域, src指向数据的接口地址=&gt;只支持get方法 具体过程 客户端定义回调方法, 预定义数据操作 将回调方法的名称, 以URL传参, 提交至服务器数据接口 服务器组装好要发送的数据, 结合客户端传来的方法名, 拼接成调用方法的字符串, 发送给客户端解析 客户端把收到的字符串以script脚本解析执行 其他跨域解决方法]]></content>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode中快速创建自定义模板]]></title>
    <url>%2F2019%2F04%2F06%2Fvscode-%E7%94%9F%E6%88%90%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[以创建vue的html模板为例 在html.json模板下编写 在VS Code 中找到设置 -&gt; 用户代码片段, 在输入框内输入 html, 选择html.json/html 编写自定义模板, 保存 基本的html框架 script中vue的路径配置 基本的vue代码 模板如下 1234567891011121314151617181920212223242526"Html5-Vue": &#123;"prefix": "vue","body": [ "&lt;!DOCTYPE html&gt;", "&lt;html lang=\"zh-CN\"&gt;\n", "&lt;head&gt;", "\t&lt;meta charset=\"UTF-8\"&gt;", "\t&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;", "\t&lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;", "\t&lt;title&gt;Document&lt;/title&gt;", "\t&lt;script src=\"../lib/vue-2.6.10/vue.js\"&gt;&lt;/script&gt;", "&lt;/head&gt;\n", "&lt;body&gt;", "\t&lt;div id=\"app\"&gt;$1&lt;/div&gt;\n", "\t&lt;script&gt;", "\t\tvar vm = new Vue(&#123;", "\t\t\tel: '#app',", "\t\t\tdata: &#123;&#125;,", "\t\t\tmethods: &#123;&#125;", "\t\t&#125;);", "\t&lt;/script&gt;", "&lt;/body&gt;\n", "&lt;/html&gt;"],"description": "快速创建在html5编写的vue模板"&#125; 创建一个html文件, 输入vue 回车生成自定义模板. 温馨提示 “prefix” : 触发模板的关键字 模板都在”body”:[ ]中编写 每行模板都用双引号 双引号中的双引号需要转义 $1 表示光标 不能覆盖json文件自带的 { }]]></content>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HTML]-Label标签]]></title>
    <url>%2F2019%2F04%2F02%2Fhtml-label-for%2F</url>
    <content type="text"><![CDATA[Label标签for属性的介绍 \专为input元素服务, 为其定义标记 for属性规定label与哪个表单元素绑定 label和表单控件绑定方式 隐式绑定 : 将表单控件作为label的内容 1&lt;label&gt;username:&lt;input type='text' id='un'&gt;&lt;/label&gt; 显示绑定 : 12&lt;label for='un'&gt;username:&lt;/label&gt;&lt;input type='text' id='un'&gt; 为啥要添加for属性呢? 提高鼠标用户的体验 在label元素内点击文本,会触发此控件. Label-for的具体应用 简单应用 123456789101112131415&lt;form&gt; &lt;label for="male"&gt;Male&lt;/label&gt; &lt;input type="radio" name="sex" id="male" /&gt; &lt;br /&gt; &lt;label for="female"&gt;Female&lt;/label&gt; &lt;input type="radio" name="sex" id="female" /&gt;&lt;/form&gt;&lt;form&gt; &lt;label for="jk"&gt;计科 : &lt;/label&gt; &lt;input type="checkbox" name="major" id="jk" /&gt; &lt;br /&gt; &lt;label for="rg"&gt;软工 : &lt;/label&gt; &lt;input type="checkbox" name="major" id="rg" /&gt;&lt;/form&gt; 纯CSS实现幻灯片 CSS代码 123456789101112img &#123; width: 200px; height: 150px; display: none;&#125;input[name='pic'] &#123; position: absolute; left: -999px;&#125;input:checked+img &#123; display: block;&#125; HTML代码 12345678910111213&lt;div&gt; &lt;input type="radio" name='pic' checked id='pic1'&gt; &lt;img src="./pic1.jpg" alt="pic1"&gt; &lt;input type="radio" name='pic' id='pic2'&gt; &lt;img src="./pic2.jpg" alt="pic2"&gt; &lt;div&gt; &lt;label for="pic1"&gt;图片1&lt;/label&gt; &lt;label for="pic2"&gt;图片2&lt;/label&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[PHP]-获取上传的文件并保存]]></title>
    <url>%2F2019%2F04%2F02%2Fphp-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[前端代码界面 注意: 上传文件格式: enctype=”multipart/form-data” 1234567&lt;form action="upload_file.php" method="post" enctype="multipart/form-data"&gt; &lt;label for="file"&gt;Filename:&lt;/label&gt; &lt;input type="file" name="myFiles[]" id="file1" /&gt; &lt;input type="file" name="myFiles[]" id="file2" /&gt; &lt;br /&gt; &lt;input type="submit" name="submit" value="Submit" /&gt;&lt;/form&gt; PHP服务器代码修改文件名,便于整理12345//1.获取文件后缀$suffix = substr($file_name,strrpos($file_name,'.'));//2.生成独一无二的时间+随机数并组合$newFileNme = date('Ymdhis',time()).rand().$suffix; 上传多个文件时,存于数组,便于操作.1234567891011121314151617181920212223242526272829303132333435363738//将获取的文件对象以数组形式保存function reArrayFiles(&amp;$file_post) &#123; $file_ary = array(); $file_count = count($file_post['name']); $file_keys = array_keys($file_post); for ($i=0; $i&lt;$file_count; $i++) &#123; foreach ($file_keys as $key) &#123; $file_ary[$i][$key] = $file_post[$key][$i]; &#125; &#125; return $file_ary;&#125;if ($_FILES['myFiles']) &#123; $file_ary = reArrayFiles($_FILES['myFiles']); //遍历获取的文件 foreach ($file_ary as $file) &#123; echo '&lt;br&gt;'; print 'File Name: ' . $file['name'].'&lt;br&gt;'; print 'File Type: ' . $file['type'].'&lt;br&gt;'; print 'File Size: ' . $file['size'].'&lt;br&gt;'; print 'File Size: ' . $file['tmp_name'].'&lt;br&gt;'; //保存文件到指定的目录 //1.如果不将临时文件保存,临时文件会自动删除 //2.临时文件存放目录在php.ini中定义 if (file_exists("upload/" . $file['name']))&#123; echo $file['name'] . " already exists. "; &#125;else &#123; move_uploaded_file($file['name'],"upload/" . $file['tmp_name']); echo "Stored in: " . "upload/" .$file['name']; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[DB]-数据库设计]]></title>
    <url>%2F2019%2F04%2F01%2Fmysql-%E5%88%9B%E5%BB%BA%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据库设计简介 六个阶段 系统需求分析 概念结构设计 逻辑结构设计 物理结构设计 数据库的实施 数据库的运行与维护 系统需求分析1.需求分析的任务通过详细调查现实世界要处理的对象 (组织,部门,企业等), 充分了解原系统的工作概况(手工系统或计算机系统), 明确用户的各种需求, 然后在此基础上确定新系统的功能. 调查重点 信息要求, 用户需要获取的数据 处理要求, 用户要完成那些数据处理功能 安全性和完整性要求 2.需求分析的方法 跟班作业 询问 设计用户调查表 查阅记录, 查阅与原系统有关的数据记录 概念结构设计1.概念结构设计简介 从需求分析中找到实体，确认实体的属性、确认实体的关系，画出ER图。 2.概念设计结构步骤 需求分析数据–&gt;局部ER图–&gt;全局ER图 合并局部ER图的关键是消除冲突 属性冲突 命名冲突 结构冲突 逻辑结构设计1.逻辑结构简介 目的是将E-R图中的实体、属性和联系转换成为关系模式。 2.初始关系模型设计实体间关系转换的原则 一个实体转换为一个关系模式,实体的属性就是关系的属性,实体的键就是关系的键. 一个联系转为一个关系模式,与该联系相连的实体以及联系的属性都是该关系的属性. 关系的键有三种情况: 联系1:1,每个实体的键都是关系的候选键 联系1:n,则n端实体的键为关系的键 联系n:m,则各实体键的组合为关系的键 三个或三个实体的多元联系的码是各实体的码组成的关系码或者关系码的一部分 具有相同码的关系模式可以合并 实体间关系转换的规则 一个1:1的关系可以转换为一个独立的关系模式,也可以与任意一端对应关系模式合并. 3.关系模式规范化三大范式 1NF: 属性不可再分 2NF: 在1NF基础上, 每一个非主属性完全函数依赖于任何一个候选码( 每个表只描述一件事,每条记录有唯一标识列 ) 3NF: 在2NF基础上, 每一个非主属性既不传递依赖与码,也不部分依赖于码. ( 数据库表不包含已在其它表中存在的非主属性 ) 物理结构设计1.物理结构设计简介 给逻辑模型, 选取最合适应用环境的物理结构 2.确定物理结构存储结构的设计数据存取路径的设计数据存放位置的设计系统配置的设计3.评价物理结构 定量估算各种方案的存储空间、存取时间和维护代价入手，对估算结果进行权衡、比较，选择出一个较优的合理的物理结构 数据库的实施数据库的运行与维护]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[PHP]-namespace]]></title>
    <url>%2F2019%2F03%2F31%2Fphp-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[命名空间概述什么是命名空间 概念: 一种封装事物的方法.例如: 函数,类,方法 作用: 解决类名或者应用程序名冲突问题 第三方类加载后可能与项目中的类名冲突. 命名空间是虚拟空间,由 \ 分割空间路径 定义命名空间的要求 namespace 空间名 所有代码均可存在, 仅有三种代码 类, 常量(const), 函数受空间影响 PHP脚本的第一行,不可有空格等(注释不算) 定义子命名空间 举例: APP\Home\Controller 不建议一个文件有多个空间 简单组合法12345678910111213141516171819namespace APP\Home\Controller;class Student&#123; private $name = "李瑞恒"; public function __construct() &#123; echo "我的名字:&#123;$this-&gt;name&#125;"; &#125;&#125;namespace APP\Home\Model;class Student&#123; private $name = "库里"; public function __construct() &#123; echo "&lt;br&gt;我的名字:&#123;$this-&gt;name&#125;&lt;br&gt;"; &#125;&#125; 大括号语法 要加大括号,所有空间都必须加. 123456789101112131415161718namespace APP\Home\Controller&#123; class Student&#123; private $name = "李瑞恒"; public function __construct() &#123; echo "我的名字:&#123;$this-&gt;name&#125;"; &#125; &#125;&#125;namespace APP\Home\Model&#123; class Student&#123; private $name = "库里"; public function __construct() &#123; echo "&lt;br&gt;我的名字:&#123;$this-&gt;name&#125;&lt;br&gt;"; &#125; &#125;&#125; 不包含在命名空间中的代码 如何用大括号定义多个命名空间,且要实现全局代码不加到空间中?可以声明匿名空间! 声明匿名空间(全局空间,根空间)12345678namespace&#123; class Teacher&#123; public function __construct($name) &#123; echo "&lt;br&gt;我的名字:&#123;$name&#125;&lt;br&gt;"; &#125; &#125;&#125; 使用命名空间 非限定访问(当前目录) 限定访问(相对路径) 完全限定访问(从根目录开始找) namespace和NAMESPACEnamespace 声明空间关键字 直接代替当前代码空间,相当于self关键字 __NAMESPACE__ 获取当前命名空间的字符串 命名空间的导入 导入空间的类,常量函数不能导入 use App\Home\Controller\Student,默认类名为Student use App\Home\Controller,默认空间别名为Controller 使用 as 给空间起别名: use App\Home\Controller as Controller 给空间的类起别名: use App\Home\Controller\Student as Student2 命名空间在项目中的使用12345678//将带空间的类名转化为真实的类文件路径//传递过来的类名: \Frame\Libs\Db//类文件的真实路径: /Frame/Libs/Db.class.php$filename = "./".str_replace('\\','/',$className).".class.php";//如果类文件存在,则包含if(file_exists($filename)) require_once($filename);]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Smarty]-简单用法]]></title>
    <url>%2F2019%2F03%2F30%2Fmvc-smarty%2F</url>
    <content type="text"><![CDATA[如何分离代码? 前端人员: {$name} PHP只能解释的代码: 1&lt;?php echo $name?&gt; 通过查找替换 常用PHP模板smarty : PHP模板引擎的祖师,其他模板都是它的二次开发. smarty初始化12345678910111213//1.包含smarty类文件 require("../smarty-3.1.33/libs/Smarty.class.php");//2.创建Smarty类对象 $smarty = new Smarty();//3.Smarty配置 $smarty-&gt;left_delimiter="&lt;&#123;"; $smarty-&gt;right_delimiter="&#125;&gt;";//4.向视图文件赋值 $smarty-&gt;assign("name","李白"); $smarty-&gt;assign('age',22); smarty的配置 左右定界符 $smarty-&gt;left_delimiter=&quot;&lt;{&quot;; $smarty-&gt;right_delimiter=&quot;}&gt;&quot;; smarty常用目录配置 设置或读取视图文件目录 $smarty-&gt;setTemplateDir(“../App/Home/View”); $smarty-&gt;getTemplateDir() 其他目录的读取或设置 smarty中的变量普通变量 所有的PHP变量都可传到视图文件 对象和资源变量不常用 保留变量 访问请求页面的变量 所有的超全局数组变量,可以在视图直接使用 {$smarty.get.parm} {$smarty.post.parm} {$smarty.request.parm} {$smarty.server.parm} {$smarty.session.parm} {$smarty.cookie.parm} {$smarty.files.parm} 时间戳 {$smarty.now|date_format:} 配置变量 前端人员在.conf配置的变量,可以分组. .conf文件 123456[cn]author = 李瑞恒sex = 男[en]author = henrysex = male controller.php 1$smarty-&gt;setConfigDir("../App/Conf"); view.html 12345&lt;!-- 加载配置文件 --&gt;&lt;&#123;config_load file="myConfig.conf"section=$smarty.get.lan&#125;&gt;&lt;!-- 读取分组配置文件参数 --&gt;&lt;&#123;#author#&#125;&gt;&lt;&#123;$smarty.config.sex&#125;&gt; smarty中的循环-foreach foreach遍历一维数组 12345678&lt;&#123;foreach $arr as $key=&gt;$value&#125;&gt; &lt;!-- 循环的内容 --&gt; $arr[&lt;&#123;$key&#125;&gt;] =&lt;&#123;$value&#125;&gt;;&lt;br&gt;&lt;&#123;/foreach&#125;&gt; &lt;!-- 描述性写法 --&gt;&#123;foreach from='' key='' item=''&#125;&#123;/foreach&#125; foreach遍历二维数组 1234567891011&lt;table width='300' border="1"&gt; &lt;&#123;foreach $arrs as $arr&#125;&gt; &lt;tr&gt; &lt;&#123;foreach $arr as $value&#125;&gt; &lt;td&gt; &lt;&#123;$value&#125;&gt; &lt;/td&gt; &lt;&#123;/foreach&#125;&gt; &lt;/tr&gt; &lt;&#123;/foreach&#125;&gt;&lt;/table&gt; foreach的常用属性 &lt;{$value}&gt; 元素的值 &lt;{$value@key}&gt; 元素下标 &lt;{$value@index}&gt; 从0开始计数 &lt;{$value@iteration}&gt; 从1开始计数 &lt;{$value@first}&gt; 是否第1次循环 &lt;{$value@last}&gt; 是否最后1次循环 &lt;{$value@total}&gt; 循环总数 smarty中的循环-section123456&#123;section name='' loop='' start='' step='' max=''&#125;&#123;/section&#125;&lt;!-- 用法 --&gt;&lt;&#123;section name=i loop=$arr&#125;&gt; &lt;&#123;$arr[i]&#125;&gt;&lt;&#123;/section&#125;&gt; 语法说明 name:循环索引(必须) loop:循环数组(必须) start:初始索引 step:循环增长值 max:最大循环次数 smarty中的判断语句-if语句1234567&#123;if 条件1&#125; //code&#123;elseif 条件2&#125; //code&#123;else&#125; //code&#123;/if&#125; smarty中的变量调节器 语法 1&#123;$var|调节器1:参数1:参数2:参数n|调节器2|...&#125; 语法说明 $var` 要修饰的变量 | 分割调节器函数 : 分割调节器函数的参数 PHP查找替换:str_replace(目标,结果,原始变量) {str_replace(&#39;Itcast&#39;,&#39;传智播客&#39;,$title)} smarty变量调节器替换 {$title|replace:’Itcast’:’传智播客’} 常用变量调节器 date_format 1234当前时间戳:&lt;&#123;time()&#125;&gt;当前时间戳:&lt;&#123;$smarty.now&#125;&gt;格式化时间戳:&lt;&#123;date( 'Y-m-d H:i:s',time())&#125;&gt;格式化时间戳: &lt;&#123;$smarty.now|date_format: '%Y-%m-%d %H:%M:%S'&#125;&gt;]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>SMARTY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[PHP]-PDO]]></title>
    <url>%2F2019%2F03%2F30%2Fphp-pdo%2F</url>
    <content type="text"><![CDATA[PDO简介 PDO: php data object 主要功能: 代替数据库操作类 PDO连接mysql 语法: 1234567PDO::_construct(string $dsn[,string $username[,string $password]])$dsn = "mysql:host=127.0.0.1;port=3306;dbname=pdo_test";$username = 'root';$password = "root";$pdo = new PDO($dsn, $username, $password); PDO常用方法 exec() 执行一条sql语句,返回受影响的行数 query() 执行select,show语句,并返回一个结果集对象(PDOStatement) lastInsertId() 获取插入的记录的ID值 setAttribute() 设置属性 语法:bool PDO::setAttribute(int $attribute,mixed $value) PDOStatement结果集对象常用方法: fetch() 获取结果集的一条记录,指针自动跳转mixed PDOStatement::fetch([int $fetch_style]) fetchAll() 获取结果集的多条记录 fetchColumn() 返回结果集的单独一列,默认为0 rowCount() 返回受上一个sql语句影响的行数 常用foreach遍历 123foreach($PDOStatement as $arr)&#123; print_r($arr);&#125; PDO错误处理模式 错误处理概述 静默模式:不显示任何错误(默认) 警告模式:用PHP的错误等级来报告信息 异常模式:先抛出异常,再处理异常 静默模式 获取错误信息函数 PDO:errorCode(); 获取状态错误码.[00000]正常 PDO:errorInfo(); 获取错误信息 警告模式 必须先设置错误报告模式(在网页直接显示错误或者警告信息) $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_WARNING); 异常模式 123456789$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);try&#123; //要执行的sql语句&#125;catch(PDOException $e)&#123; ehco "错误行号:".$e-&gt;getLine(); ehco "&lt;br&gt;错误文件:".$e-&gt;getFile(); ehco "&lt;br&gt;错误状态码:".$e-&gt;getCode(); ehco "&lt;br&gt;错误信息:".$e-&gt;getMessage();&#125; PDO预处理模式 sql语句的执行(编译和执行) 如果是第一次执行,先编译后执行,切编译过程非常复杂 如果是第二次执行(相同sql语句),直接从缓存中读取,效率高,安全,有效防止sql语句注入. 预处理步骤 先提取相同结构语句 编译结构,保存结果 再将不同数据部分替换 执行预处理语句 1234567891011121314//(1)使用占位符":value"来代替真正的数据 $sql = "INSERT INTO user(username,password) VALUES(:username,:password)"; $sql = "INSERT INTO user(username,password) VALUES(?,?)";//(2)预编译相同结构的sql语句,返回结果集对象$PDOStatement = $pdo-&gt;prepare($sql);//(3)给占位符绑定真正的数据$PDOStatement-&gt;bindValue(":username","henry");$PDOStatement-&gt;bindValue(":password","566");$PDOStatement-&gt;bindValue("1","henry");$PDOStatement-&gt;bindValue("2","566");//(4)执行预编译sql语句$PDOStatement-&gt;execute();]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CSS]-高度坍塌问题]]></title>
    <url>%2F2019%2F03%2F29%2FCSS-%E9%AB%98%E5%BA%A6%E5%9D%8D%E5%A1%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[浮动塌陷如果父元素只包含浮动元素,且未设置高度,那么它的高度将坍塌为0.因为浮动元素脱离了文档流,包含他们的父块没有内容,发生塌陷. 解决方案 使用clear属性的空元素 1&lt;div style="clear:both"&gt;&lt;/div&gt; 使用css的overflow属性 给浮动元素的容器添加: 1overflow:hidden||auto; 给浮动元素的容器添加浮动 使用css的:after伪元素(推荐使用) 123.cf:after &#123; clear: both;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ES6]-let&const]]></title>
    <url>%2F2019%2F03%2F29%2FES6-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[let let类似于var,但是声明的变量只在该代码块有效 不存在变量提升 暂时性死区 使用let声明变量之前,该变量不可使用 不允许重复声明 块级作用域 块级作用域的出现取代了立即执行函数. 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 块级作用域可以多层嵌套 不建议在块级作用域声明函数,如果需要,也应该使用函数表达式 const const声明一个只读的常量,一旦声明,无法改变.因此声明的同时必须立即赋值. 存在暂时性死区 不可重复声明]]></content>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
