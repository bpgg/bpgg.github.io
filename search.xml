<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[PHP]-namespace]]></title>
    <url>%2F2019%2F03%2F31%2Fphp-namespace%2F</url>
    <content type="text"><![CDATA[命名空间概述什么是命名空间 概念: 一种封装事物的方法.例如: 函数,类,方法 作用: 解决类名或者应用程序名冲突问题 第三方类加载后可能与项目中的类名冲突. 命名空间是虚拟空间,由 \ 分割空间路径 定义命名空间的要求 namespace 空间名 所有代码均可存在, 仅有三种代码 类, 常量(const), 函数受空间影响 PHP脚本的第一行,不可有空格等(注释不算) 定义子命名空间 举例: APP\Home\Controller 不建议一个文件有多个空间 简单组合法12345678910111213141516171819namespace APP\Home\Controller;class Student&#123; private $name = &quot;李瑞恒&quot;; public function __construct() &#123; echo &quot;我的名字:&#123;$this-&gt;name&#125;&quot;; &#125;&#125;namespace APP\Home\Model;class Student&#123; private $name = &quot;库里&quot;; public function __construct() &#123; echo &quot;&lt;br&gt;我的名字:&#123;$this-&gt;name&#125;&lt;br&gt;&quot;; &#125;&#125; 大括号语法 要加大括号,所有空间都必须加. 123456789101112131415161718namespace APP\Home\Controller&#123; class Student&#123; private $name = &quot;李瑞恒&quot;; public function __construct() &#123; echo &quot;我的名字:&#123;$this-&gt;name&#125;&quot;; &#125; &#125;&#125;namespace APP\Home\Model&#123; class Student&#123; private $name = &quot;库里&quot;; public function __construct() &#123; echo &quot;&lt;br&gt;我的名字:&#123;$this-&gt;name&#125;&lt;br&gt;&quot;; &#125; &#125;&#125; 不包含在命名空间中的代码 如何用大括号定义多个命名空间,且要实现全局代码不加到空间中?可以声明匿名空间! 声明匿名空间(全局空间,根空间)12345678namespace&#123; class Teacher&#123; public function __construct($name) &#123; echo &quot;&lt;br&gt;我的名字:&#123;$name&#125;&lt;br&gt;&quot;; &#125; &#125;&#125; 使用命名空间 非限定访问(当前目录) 限定访问(相对路径) 完全限定访问(从根目录开始找) namespace和NAMESPACEnamespace 声明空间关键字 直接代替当前代码空间,相当于self关键字 __NAMESPACE__ 获取当前命名空间的字符串 命名空间的导入 导入空间的类,常量函数不能导入 use App\Home\Controller\Student,默认类名为Student use App\Home\Controller,默认空间别名为Controller 使用 as 给空间起别名: use App\Home\Controller as Controller 给空间的类起别名: use App\Home\Controller\Student as Student2 命名空间在项目中的使用12345678//将带空间的类名转化为真实的类文件路径//传递过来的类名: \Frame\Libs\Db//类文件的真实路径: /Frame/Libs/Db.class.php$filename = &quot;./&quot;.str_replace(&apos;\\&apos;,&apos;/&apos;,$className).&quot;.class.php&quot;;//如果类文件存在,则包含if(file_exists($filename)) require_once($filename);]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Smarty]-简单用法]]></title>
    <url>%2F2019%2F03%2F30%2Fsmarty%2F</url>
    <content type="text"><![CDATA[如何分离代码? 前端人员: {$name} PHP只能解释的代码:&lt;?php echo $name?&gt; 通过查找替换 常用PHP模板smarty : PHP模板引擎的祖师,其他模板都是它的二次开发. smarty初始化12345678910111213//1.包含smarty类文件 require(&quot;../smarty-3.1.33/libs/Smarty.class.php&quot;);//2.创建Smarty类对象 $smarty = new Smarty();//3.Smarty配置 $smarty-&gt;left_delimiter=&quot;&lt;&#123;&quot;; $smarty-&gt;right_delimiter=&quot;&#125;&gt;&quot;;//4.向视图文件赋值 $smarty-&gt;assign(&quot;name&quot;,&quot;李白&quot;); $smarty-&gt;assign(&apos;age&apos;,22); smarty的配置 左右定界符 $smarty-&gt;left_delimiter=”&lt;{“; $smarty-&gt;right_delimiter=”}&gt;”; smarty常用目录配置 设置或读取视图文件目录 $smarty-&gt;setTemplateDir(“../App/Home/View”); $smarty-&gt;getTemplateDir() 其他目录的读取或设置 smarty中的变量普通变量 所有的PHP变量都可传到视图文件 对象和资源变量不常用 保留变量 访问请求页面的变量 所有的超全局数组变量,可以在视图直接使用 {$smarty.get.parm} {$smarty.post.parm} {$smarty.request.parm} {$smarty.server.parm} {$smarty.session.parm} {$smarty.cookie.parm} {$smarty.files.parm} 时间戳 {$smarty.now|date_format:} 配置变量前端人员在.conf配置的变量,可以分组. .conf文件 123456[cn]author = 李瑞恒sex = 男[en]author = henrysex = male controller.php 1$smarty-&gt;setConfigDir(&quot;../App/Conf&quot;); view.html 12345// 加载配置文件&lt;&#123;config_load file=&quot;myConfig.conf&quot; section=$smarty.get.lan&#125;&gt;//读取分组配置文件参数 &lt;&#123;#author#&#125;&gt; &lt;&#123;$smarty.config.sex&#125;&gt; smarty中的循环-foreach foreach遍历一维数组 12345678&lt;&#123;foreach $arr as $key=&gt;$value&#125;&gt; //循环的内容 $arr[&lt;&#123;$key&#125;&gt;] =&lt;&#123;$value&#125;&gt;;&lt;br&gt;&lt;&#123;/foreach&#125;&gt; //描述性写法&#123;foreach from=&apos;&apos; key=&apos;&apos; item=&apos;&apos;&#125;&#123;/foreach&#125; foreach遍历二维数组 1234567891011&lt;table width=&apos;300&apos; border=&quot;1&quot;&gt; &lt;&#123;foreach $arrs as $arr&#125;&gt; &lt;tr&gt; &lt;&#123;foreach $arr as $value&#125;&gt; &lt;td&gt; &lt;&#123;$value&#125;&gt; &lt;/td&gt; &lt;&#123;/foreach&#125;&gt; &lt;/tr&gt; &lt;&#123;/foreach&#125;&gt;&lt;/table&gt; foreach的常用属性 &lt;{$value}&gt; 元素的值 &lt;{$value@key}&gt; 元素下标 &lt;{$value@index}&gt; 从0开始计数 &lt;{$value@iteration}&gt; 从1开始计数 &lt;{$value@first}&gt; 是否第1次循环 &lt;{$value@last}&gt; 是否最后1次循环 &lt;{$value@total}&gt; 循环总数 smarty中的循环-section1234567&#123;section name=&apos;&apos; loop=&apos;&apos; start=&apos;&apos; step=&apos;&apos; max=&apos;&apos;&#125;&#123;/section&#125;//用法&lt;&#123;section name=i loop=$arr&#125;&gt; &lt;&#123;$arr[i]&#125;&gt;&lt;&#123;/section&#125;&gt; 语法说明 name:循环索引(必须) loop:循环数组(必须) start:初始索引 step:循环增长值 max:最大循环次数 smarty中的判断语句-if语句1234567&#123;if 条件1&#125; //code&#123;elseif 条件2&#125; //code&#123;else&#125; //code&#123;/if&#125; smarty中的变量调节器 语法 1&#123;$var|调节器1:参数1:参数2:参数n|调节器2|...&#125; 语法说明 $var 要修饰的变量 | 分割调节器函数 : 分割调节器函数的参数 PHP查找替换:str_replace(目标,结果,原始变量) {str_replace(‘Itcast’,’传智播客’,$title)} smarty变量调节器替换 {$title|replace:’Itcast’:’传智播客’} 常用变量调节器 date_format1234当前时间戳:&lt;&#123;time()&#125;&gt;当前时间戳:&lt;&#123;$smarty.now&#125;&gt;格式化时间戳:&lt;&#123;date( &apos;Y-m-d H:i:s&apos;,time())&#125;&gt;格式化时间戳: &lt;&#123;$smarty.now|date_format: &apos;%Y-%m-%d %H:%M:%S&apos;&#125;&gt;]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>SMARTY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[PHP]-PDO]]></title>
    <url>%2F2019%2F03%2F30%2Fpdo%2F</url>
    <content type="text"><![CDATA[PDO简介 PDO: php data object 主要功能: 代替数据库操作类 PDO连接mysql 语法: 1234567PDO::_construct(string $dsn[,string $username[,string $password]])$dsn = &quot;mysql:host=127.0.0.1;port=3306;dbname=pdo_test&quot;;$username = &apos;root&apos;;$password = &quot;root&quot;;$pdo = new PDO($dsn, $username, $password); PDO常用方法 exec() 执行一条sql语句,返回受影响的行数 query() 执行select,show语句,并返回一个结果集对象(PDOStatement) lastInsertId() 获取插入的记录的ID值 setAttribute() 设置属性 语法:bool PDO::setAttribute(int $attribute,mixed $value) PDOStatement结果集对象常用方法: fetch() 获取结果集的一条记录,指针自动跳转 mixed PDOStatement::fetch([int $fetch_style]) fetchAll() 获取结果集的多条记录 fetchColumn() 返回结果集的单独一列,默认为0 rowCount() 返回受上一个sql语句影响的行数 常用foreach遍历 123foreach($PDOStatement as $arr)&#123; print_r($arr);&#125; PDO错误处理模式: 错误处理概述 静默模式:不显示任何错误(默认) 警告模式:用PHP的错误等级来报告信息 异常模式:先抛出异常,再处理异常 静默模式 获取错误信息函数 PDO:errorCode(); 获取状态错误码.[00000]正常 PDO:errorInfo(); 获取错误信息 警告模式 必须先设置错误报告模式(在网页直接显示错误或者警告信息) $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_WARNING); 异常模式 123456789$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);try&#123; //要执行的sql语句&#125;catch(PDOException $e)&#123; ehco &quot;错误行号:&quot;.$e-&gt;getLine(); ehco &quot;&lt;br&gt;错误文件:&quot;.$e-&gt;getFile(); ehco &quot;&lt;br&gt;错误状态码:&quot;.$e-&gt;getCode(); ehco &quot;&lt;br&gt;错误信息:&quot;.$e-&gt;getMessage();&#125; PDO预处理模式 sql语句的执行(编译和执行) 如果是第一次执行,先编译后执行,切编译过程非常复杂 如果是第二次执行(相同sql语句),直接从缓存中读取,效率高,安全,有效防止sql语句注入. 预处理步骤 先提取相同结构语句 编译结构,保存结果 再将不同数据部分替换 执行预处理语句 123456789101112131415161718//(1)使用占位符&quot;:value&quot;来代替真正的数据 $sql = &quot;INSERT INTO user(username,password) VALUES(:username,:password)&quot;; $sql = &quot;INSERT INTO user(username,password) VALUES(?,?)&quot;;//(2)预编译相同结构的sql语句,返回结果集对象$PDOStatement = $pdo-&gt;prepare($sql);//(3)给占位符绑定真正的数据$PDOStatement-&gt;bindValue(&quot;:username&quot;,&quot;henry&quot;);$PDOStatement-&gt;bindValue(&quot;:password&quot;,&quot;566&quot;);$PDOStatement-&gt;bindValue(&quot;1&quot;,&quot;henry&quot;);$PDOStatement-&gt;bindValue(&quot;2&quot;,&quot;566&quot;);//(4)执行预编译sql语句$PDOStatement-&gt;execute();]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CSS]-高度坍塌问题]]></title>
    <url>%2F2019%2F03%2F29%2FCSS-%E9%AB%98%E5%BA%A6%E5%9D%8D%E5%A1%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[浮动塌陷如果父元素只包含浮动元素,且未设置高度,那么它的高度将坍塌为0.因为浮动元素脱离了文档流,包含他们的父块没有内容,发生塌陷. 解决方案 使用clear属性的空元素 1&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt; 使用css的overflow属性 给浮动元素的容器添加: 1overflow:hidden||auto; 给浮动元素的容器添加浮动 使用css的:after伪元素(推荐使用)123.cf:after &#123; clear: both;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ES6]-let&const]]></title>
    <url>%2F2019%2F03%2F29%2FES6-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[let let类似于var,但是声明的变量只在该代码块有效 不存在变量提升 暂时性死区 使用let声明变量之前,该变量不可使用 不允许重复声明 块级作用域 块级作用域的出现取代了立即执行函数. 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 块级作用域可以多层嵌套 不建议在块级作用域声明函数,如果需要,也应该使用函数表达式 const const声明一个只读的常量,一旦声明,无法改变.因此声明的同时必须立即赋值. 存在暂时性死区 不可重复声明]]></content>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
