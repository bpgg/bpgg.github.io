<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[[JS]-单线程及异步]]></title>
    <url>%2F2019%2F04%2F23%2Fjs-%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%8F%8A%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[JS的主线程及执行栈前言 JS是一门单线程语言，那为何能够实现异步操作呢？ 单线程和异步操作确实不能同时成为一个语言的特性。JS本身不能实现异步，但是JS的宿主环境（浏览器，Node）是多线程的，宿主环境通过某种方式，使得JS具备了异步的特性。 浏览器JS是单线程语言，浏览器只分配给JS一个主线程，用来执行任务（函数），但一次只能执行一个任务，这些任务形成一个任务队列排队等候执行，但前端的某些任务是非常耗时的，比如网络请求，定时器和事件监听，如果让他们和别的任务一样，都老老实实的排队等待执行的话，执行效率会非常的低，甚至导致页面的假死。 浏览器为这些耗时任务开辟了另外的线程，主要包括http请求线程，浏览器定时触发器，浏览器事件触发线程，这些任务是异步的。 任务队列浏览器为这些异步任务单独开了一个线程，那么主线程是如何知道异步任务是否已经完成呢？这就需要依赖回调函数了，整个程序是靠事件驱动的，每个事件都有相应的回调函数。 123setTimeout(function()&#123; console.log('time up);&#125;,50) 主线程 JS一直在做一个工作，就是从任务队列里提取任务，放到主线程里执行。 浏览器为异步任务开启的线程序=&gt;WebAPIs 任务队列=&gt;callback queue 主线程 堆和栈 函数的执行就是通过进栈和出栈实现 栈stack清空时，说明一个任务已经执行完成，这时会从callback queue中寻找下一个任务推入栈中 容易困惑的问题setTimeout(f1,0)是否立即执行123456setTimeout(()=&gt;&#123; console.log(1)&#125;,0)console.log(2)// output =&gt; 2,1 当执行setTimeout后，浏览器会立即把匿名函数放入callback queue中，等待主线程的召唤，因为此时的stack还有console.log(2)尚未执行。等console.log(2)执行完毕后，才通过event loop把匿名函数放到stack中执行。 结论： setTimeout(f1,0)并非无意义，若f1是比较耗时的任务，又不在WebAPIs中，那就可以把它放到callback queue，等待主线程执行完毕后再执行。 若当前代码执行时间很长，没有办法保证回调函数一定会在setTimeout指定的时间内完成。 补充说明： HTML5标准规定了setTimeout()的第二个参数的最小值（最短间隔），不得低于4毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为10毫秒。 DOM的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每16毫秒执行一次。这时使用requestAnimationFrame()的效果要好于setTimeout() 浏览器异步机制的使用 当我们自己需要写的程序中也有比较耗时的函数。可以通过浏览器提供给我们的浏览器定时事件和事件触发线程。 异步的好处和使用场景 异步的好处 同步执行 异步执行 使用场景 程序需要大量I/O操作和用户请求时]]></content>
  </entry>
  <entry>
    <title><![CDATA[[webpack]-基础知识及配置]]></title>
    <url>%2F2019%2F04%2F17%2Fwebpack-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[webpack 4.x的使用 需要安装 webpack webpack-cli 基本使用 webpack a.js -o b.js webpack.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172module.exports = &#123; devServer: &#123; port: 3000, progress: true, contentBase: './dist', //默认打开哪个目录 compress: true open:true &#125;, entry: path.join(__dirname, "./src/main.js"), output: &#123; path: path.join(__dirname, "./dist"), filename: 'bundle.js' &#125;, mode: 'development', // 'produciton' plugins: [ //放置所有插件 new HtmlWebpackPlugin(&#123; template: './src/index.html', filename: 'index.html' &#125;) ], module: &#123; //解析文件的loader，使用loader解析更高级的语法和其他语言特性 rules: [ &#123; test: /\.js$/, use: &#123; loader: 'babel-loader', options: &#123; presets: [ '@babel/preset-env' ], plugins: [ ["@babel/plugin-proposal-decorators", &#123; "legacy": true &#125;], ["@babel/plugin-proposal-class-properties", &#123; "loose": true &#125;], ["@babel/plugin-transform-runtime"] ] &#125; &#125;, exclude: /node_modules/, //规定不解析该目录下的js文件 include: path.resolve(__dirname, 'src') &#125;, &#123; test: /\.css$/, use: [ 'css-loader', //'postcss-loader' ] &#125;, &#123; test: /\.less$/, use: [ 'css-loader', 'less-loader' ] &#125; ] &#125;, optimization: &#123; minimizer: [ new OptimizeCss(), new UgliyfyJsPlugin(&#123; cache: true, parallel: true, //并行压缩 sourceMap: true //源码映射 &#125;) ] &#125;&#125; package.json 配置运行的脚本命令，使用npm run dev执行对应命令 1234"scripts":&#123; "build": "webpack --config webpack.config.js", "dev": "webpack-dev-server"&#125; webpack中常用插件 打包html模板 html-webpack-plugin 解析文件的loader 解析css,style,less等 给css增加浏览器的前缀 postcss-loader，需要配置postcss.config.js 解析高级js语法的babel-loader，还需要@babel/core,@babel/preset-env等 代码校验： eslint-loader 解析css中出现的url：url-loader，file-loader 压缩css文件 optimize-css-assets-webpack-plugin 使用之后js便不会压缩，需要安装uglifyjs-webpack-plugin 源码映射 source-map 实时打包 watch 其他插件 clean-webpack-plugin 每次build的时候，重置dist copy-webpack-plugin 复制一些其他类型的文件到dist，txt等 banner-plugin 版权声明，再生成的js文件中添加自定义版权信息]]></content>
      <tags>
        <tag>wenpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[axios]]></title>
    <url>%2F2019%2F04%2F10%2Fvue-axios%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[同源策略,跨域解决]]></title>
    <url>%2F2019%2F04%2F07%2F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[浏览器同源策略,及跨域资源的解决方法同源策略 源: 服务器 同源 =&gt; 域名,协议,端口 一致 同源策略分类 DOM同源策略: 禁止对不同源页面进行DOM操作 XMLHttpRequest同源策略 : 禁止xhr对象向不同源服务器发起http请求. 跨域的解决方法CORS跨域 CORS [ Cross-origin resource sharing ], 定义在跨域时,浏览器和服务器应该如何沟通, 通过自定义的Http, 决定请求响应是否成功. 只要服务器实现CROS接口, 就可以跨域通信. CORS分类 简单请求 请求方法: HEAD GET POST 请求字段: Accept Accept-Language Content-Language Last-Event-ID Content-Type: application/x-www-form-urlencoded, multipart/form-data, text/plain 非简单请求 JSONP跨域 因为浏览器的安全性限制, 不允许ajax进行跨域(不同域名/不同端口/不同协议…)访问 通过动态创建script标签, 实现跨域, src指向数据的接口地址=&gt;只支持get方法 具体过程 客户端定义回调方法, 预定义数据操作 将回调方法的名称, 以URL传参, 提交至服务器数据接口 服务器组装好要发送的数据, 结合客户端传来的方法名, 拼接成调用方法的字符串, 发送给客户端解析 客户端把收到的字符串以script脚本解析执行 其他跨域解决方法]]></content>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VSCode中快速创建自定义模板]]></title>
    <url>%2F2019%2F04%2F06%2Fvscode-%E7%94%9F%E6%88%90%E6%A8%A1%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[以创建vue的html模板为例 在html.json模板下编写 在VS Code 中找到设置 -&gt; 用户代码片段, 在输入框内输入 html, 选择html.json/html 编写自定义模板, 保存 基本的html框架 script中vue的路径配置 基本的vue代码 模板如下 1234567891011121314151617181920212223242526"Html5-Vue": &#123;"prefix": "vue","body": [ "&lt;!DOCTYPE html&gt;", "&lt;html lang=\"zh-CN\"&gt;\n", "&lt;head&gt;", "\t&lt;meta charset=\"UTF-8\"&gt;", "\t&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;", "\t&lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;", "\t&lt;title&gt;Document&lt;/title&gt;", "\t&lt;script src=\"../lib/vue-2.6.10/vue.js\"&gt;&lt;/script&gt;", "&lt;/head&gt;\n", "&lt;body&gt;", "\t&lt;div id=\"app\"&gt;$1&lt;/div&gt;\n", "\t&lt;script&gt;", "\t\tvar vm = new Vue(&#123;", "\t\t\tel: '#app',", "\t\t\tdata: &#123;&#125;,", "\t\t\tmethods: &#123;&#125;", "\t\t&#125;);", "\t&lt;/script&gt;", "&lt;/body&gt;\n", "&lt;/html&gt;"],"description": "快速创建在html5编写的vue模板"&#125; 创建一个html文件, 输入vue 回车生成自定义模板. 温馨提示 “prefix” : 触发模板的关键字 模板都在”body”:[ ]中编写 每行模板都用双引号 双引号中的双引号需要转义 $1 表示光标 不能覆盖json文件自带的 { }]]></content>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[HTML]-Label标签]]></title>
    <url>%2F2019%2F04%2F02%2Fhtml-label-for%2F</url>
    <content type="text"><![CDATA[Label标签for属性的介绍 \专为input元素服务, 为其定义标记 for属性规定label与哪个表单元素绑定 label和表单控件绑定方式 隐式绑定 : 将表单控件作为label的内容 1&lt;label&gt;username:&lt;input type='text' id='un'&gt;&lt;/label&gt; 显示绑定 : 12&lt;label for='un'&gt;username:&lt;/label&gt;&lt;input type='text' id='un'&gt; 为啥要添加for属性呢? 提高鼠标用户的体验 在label元素内点击文本,会触发此控件. Label-for的具体应用 简单应用 123456789101112131415&lt;form&gt; &lt;label for="male"&gt;Male&lt;/label&gt; &lt;input type="radio" name="sex" id="male" /&gt; &lt;br /&gt; &lt;label for="female"&gt;Female&lt;/label&gt; &lt;input type="radio" name="sex" id="female" /&gt;&lt;/form&gt;&lt;form&gt; &lt;label for="jk"&gt;计科 : &lt;/label&gt; &lt;input type="checkbox" name="major" id="jk" /&gt; &lt;br /&gt; &lt;label for="rg"&gt;软工 : &lt;/label&gt; &lt;input type="checkbox" name="major" id="rg" /&gt;&lt;/form&gt; 纯CSS实现幻灯片 CSS代码 123456789101112img &#123; width: 200px; height: 150px; display: none;&#125;input[name='pic'] &#123; position: absolute; left: -999px;&#125;input:checked+img &#123; display: block;&#125; HTML代码 12345678910111213&lt;div&gt; &lt;input type="radio" name='pic' checked id='pic1'&gt; &lt;img src="./pic1.jpg" alt="pic1"&gt; &lt;input type="radio" name='pic' id='pic2'&gt; &lt;img src="./pic2.jpg" alt="pic2"&gt; &lt;div&gt; &lt;label for="pic1"&gt;图片1&lt;/label&gt; &lt;label for="pic2"&gt;图片2&lt;/label&gt; &lt;/div&gt;&lt;/div&gt;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[PHP]-获取上传的文件并保存]]></title>
    <url>%2F2019%2F04%2F02%2Fphp-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[前端代码界面 注意: 上传文件格式: enctype=”multipart/form-data” 1234567&lt;form action="upload_file.php" method="post" enctype="multipart/form-data"&gt; &lt;label for="file"&gt;Filename:&lt;/label&gt; &lt;input type="file" name="myFiles[]" id="file1" /&gt; &lt;input type="file" name="myFiles[]" id="file2" /&gt; &lt;br /&gt; &lt;input type="submit" name="submit" value="Submit" /&gt;&lt;/form&gt; PHP服务器代码修改文件名,便于整理12345//1.获取文件后缀$suffix = substr($file_name,strrpos($file_name,'.'));//2.生成独一无二的时间+随机数并组合$newFileNme = date('Ymdhis',time()).rand().$suffix; 上传多个文件时,存于数组,便于操作.1234567891011121314151617181920212223242526272829303132333435363738//将获取的文件对象以数组形式保存function reArrayFiles(&amp;$file_post) &#123; $file_ary = array(); $file_count = count($file_post['name']); $file_keys = array_keys($file_post); for ($i=0; $i&lt;$file_count; $i++) &#123; foreach ($file_keys as $key) &#123; $file_ary[$i][$key] = $file_post[$key][$i]; &#125; &#125; return $file_ary;&#125;if ($_FILES['myFiles']) &#123; $file_ary = reArrayFiles($_FILES['myFiles']); //遍历获取的文件 foreach ($file_ary as $file) &#123; echo '&lt;br&gt;'; print 'File Name: ' . $file['name'].'&lt;br&gt;'; print 'File Type: ' . $file['type'].'&lt;br&gt;'; print 'File Size: ' . $file['size'].'&lt;br&gt;'; print 'File Size: ' . $file['tmp_name'].'&lt;br&gt;'; //保存文件到指定的目录 //1.如果不将临时文件保存,临时文件会自动删除 //2.临时文件存放目录在php.ini中定义 if (file_exists("upload/" . $file['name']))&#123; echo $file['name'] . " already exists. "; &#125;else &#123; move_uploaded_file($file['name'],"upload/" . $file['tmp_name']); echo "Stored in: " . "upload/" .$file['name']; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[DB]-数据库设计]]></title>
    <url>%2F2019%2F04%2F01%2Fmysql-%E5%88%9B%E5%BB%BA%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[数据库设计简介 六个阶段 系统需求分析 概念结构设计 逻辑结构设计 物理结构设计 数据库的实施 数据库的运行与维护 系统需求分析1.需求分析的任务通过详细调查现实世界要处理的对象 (组织,部门,企业等), 充分了解原系统的工作概况(手工系统或计算机系统), 明确用户的各种需求, 然后在此基础上确定新系统的功能. 调查重点 信息要求, 用户需要获取的数据 处理要求, 用户要完成那些数据处理功能 安全性和完整性要求 2.需求分析的方法 跟班作业 询问 设计用户调查表 查阅记录, 查阅与原系统有关的数据记录 概念结构设计1.概念结构设计简介 从需求分析中找到实体，确认实体的属性、确认实体的关系，画出ER图。 2.概念设计结构步骤 需求分析数据–&gt;局部ER图–&gt;全局ER图 合并局部ER图的关键是消除冲突 属性冲突 命名冲突 结构冲突 逻辑结构设计1.逻辑结构简介 目的是将E-R图中的实体、属性和联系转换成为关系模式。 2.初始关系模型设计实体间关系转换的原则 一个实体转换为一个关系模式,实体的属性就是关系的属性,实体的键就是关系的键. 一个联系转为一个关系模式,与该联系相连的实体以及联系的属性都是该关系的属性. 关系的键有三种情况: 联系1:1,每个实体的键都是关系的候选键 联系1:n,则n端实体的键为关系的键 联系n:m,则各实体键的组合为关系的键 三个或三个实体的多元联系的码是各实体的码组成的关系码或者关系码的一部分 具有相同码的关系模式可以合并 实体间关系转换的规则 一个1:1的关系可以转换为一个独立的关系模式,也可以与任意一端对应关系模式合并. 3.关系模式规范化三大范式 1NF: 属性不可再分 2NF: 在1NF基础上, 每一个非主属性完全函数依赖于任何一个候选码( 每个表只描述一件事,每条记录有唯一标识列 ) 3NF: 在2NF基础上, 每一个非主属性既不传递依赖与码,也不部分依赖于码. ( 数据库表不包含已在其它表中存在的非主属性 ) 物理结构设计1.物理结构设计简介 给逻辑模型, 选取最合适应用环境的物理结构 2.确定物理结构存储结构的设计数据存取路径的设计数据存放位置的设计系统配置的设计3.评价物理结构 定量估算各种方案的存储空间、存取时间和维护代价入手，对估算结果进行权衡、比较，选择出一个较优的合理的物理结构 数据库的实施数据库的运行与维护]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[PHP]-namespace]]></title>
    <url>%2F2019%2F03%2F31%2Fphp-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[命名空间概述什么是命名空间 概念: 一种封装事物的方法.例如: 函数,类,方法 作用: 解决类名或者应用程序名冲突问题 第三方类加载后可能与项目中的类名冲突. 命名空间是虚拟空间,由 \ 分割空间路径 定义命名空间的要求 namespace 空间名 所有代码均可存在, 仅有三种代码 类, 常量(const), 函数受空间影响 PHP脚本的第一行,不可有空格等(注释不算) 定义子命名空间 举例: APP\Home\Controller 不建议一个文件有多个空间 简单组合法12345678910111213141516171819namespace APP\Home\Controller;class Student&#123; private $name = "李瑞恒"; public function __construct() &#123; echo "我的名字:&#123;$this-&gt;name&#125;"; &#125;&#125;namespace APP\Home\Model;class Student&#123; private $name = "库里"; public function __construct() &#123; echo "&lt;br&gt;我的名字:&#123;$this-&gt;name&#125;&lt;br&gt;"; &#125;&#125; 大括号语法 要加大括号,所有空间都必须加. 123456789101112131415161718namespace APP\Home\Controller&#123; class Student&#123; private $name = "李瑞恒"; public function __construct() &#123; echo "我的名字:&#123;$this-&gt;name&#125;"; &#125; &#125;&#125;namespace APP\Home\Model&#123; class Student&#123; private $name = "库里"; public function __construct() &#123; echo "&lt;br&gt;我的名字:&#123;$this-&gt;name&#125;&lt;br&gt;"; &#125; &#125;&#125; 不包含在命名空间中的代码 如何用大括号定义多个命名空间,且要实现全局代码不加到空间中?可以声明匿名空间! 声明匿名空间(全局空间,根空间)12345678namespace&#123; class Teacher&#123; public function __construct($name) &#123; echo "&lt;br&gt;我的名字:&#123;$name&#125;&lt;br&gt;"; &#125; &#125;&#125; 使用命名空间 非限定访问(当前目录) 限定访问(相对路径) 完全限定访问(从根目录开始找) namespace和NAMESPACEnamespace 声明空间关键字 直接代替当前代码空间,相当于self关键字 __NAMESPACE__ 获取当前命名空间的字符串 命名空间的导入 导入空间的类,常量函数不能导入 use App\Home\Controller\Student,默认类名为Student use App\Home\Controller,默认空间别名为Controller 使用 as 给空间起别名: use App\Home\Controller as Controller 给空间的类起别名: use App\Home\Controller\Student as Student2 命名空间在项目中的使用12345678//将带空间的类名转化为真实的类文件路径//传递过来的类名: \Frame\Libs\Db//类文件的真实路径: /Frame/Libs/Db.class.php$filename = "./".str_replace('\\','/',$className).".class.php";//如果类文件存在,则包含if(file_exists($filename)) require_once($filename);]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Smarty]-简单用法]]></title>
    <url>%2F2019%2F03%2F30%2Fmvc-smarty%2F</url>
    <content type="text"><![CDATA[如何分离代码? 前端人员: {$name} PHP只能解释的代码: 1&lt;?php echo $name?&gt; 通过查找替换 常用PHP模板smarty : PHP模板引擎的祖师,其他模板都是它的二次开发. smarty初始化12345678910111213//1.包含smarty类文件 require("../smarty-3.1.33/libs/Smarty.class.php");//2.创建Smarty类对象 $smarty = new Smarty();//3.Smarty配置 $smarty-&gt;left_delimiter="&lt;&#123;"; $smarty-&gt;right_delimiter="&#125;&gt;";//4.向视图文件赋值 $smarty-&gt;assign("name","李白"); $smarty-&gt;assign('age',22); smarty的配置 左右定界符 $smarty-&gt;left_delimiter=&quot;&lt;{&quot;; $smarty-&gt;right_delimiter=&quot;}&gt;&quot;; smarty常用目录配置 设置或读取视图文件目录 $smarty-&gt;setTemplateDir(“../App/Home/View”); $smarty-&gt;getTemplateDir() 其他目录的读取或设置 smarty中的变量普通变量 所有的PHP变量都可传到视图文件 对象和资源变量不常用 保留变量 访问请求页面的变量 所有的超全局数组变量,可以在视图直接使用 {$smarty.get.parm} {$smarty.post.parm} {$smarty.request.parm} {$smarty.server.parm} {$smarty.session.parm} {$smarty.cookie.parm} {$smarty.files.parm} 时间戳 {$smarty.now|date_format:} 配置变量 前端人员在.conf配置的变量,可以分组. .conf文件 123456[cn]author = 李瑞恒sex = 男[en]author = henrysex = male controller.php 1$smarty-&gt;setConfigDir("../App/Conf"); view.html 12345&lt;!-- 加载配置文件 --&gt;&lt;&#123;config_load file="myConfig.conf"section=$smarty.get.lan&#125;&gt;&lt;!-- 读取分组配置文件参数 --&gt;&lt;&#123;#author#&#125;&gt;&lt;&#123;$smarty.config.sex&#125;&gt; smarty中的循环-foreach foreach遍历一维数组 12345678&lt;&#123;foreach $arr as $key=&gt;$value&#125;&gt; &lt;!-- 循环的内容 --&gt; $arr[&lt;&#123;$key&#125;&gt;] =&lt;&#123;$value&#125;&gt;;&lt;br&gt;&lt;&#123;/foreach&#125;&gt; &lt;!-- 描述性写法 --&gt;&#123;foreach from='' key='' item=''&#125;&#123;/foreach&#125; foreach遍历二维数组 1234567891011&lt;table width='300' border="1"&gt; &lt;&#123;foreach $arrs as $arr&#125;&gt; &lt;tr&gt; &lt;&#123;foreach $arr as $value&#125;&gt; &lt;td&gt; &lt;&#123;$value&#125;&gt; &lt;/td&gt; &lt;&#123;/foreach&#125;&gt; &lt;/tr&gt; &lt;&#123;/foreach&#125;&gt;&lt;/table&gt; foreach的常用属性 &lt;{$value}&gt; 元素的值 &lt;{$value@key}&gt; 元素下标 &lt;{$value@index}&gt; 从0开始计数 &lt;{$value@iteration}&gt; 从1开始计数 &lt;{$value@first}&gt; 是否第1次循环 &lt;{$value@last}&gt; 是否最后1次循环 &lt;{$value@total}&gt; 循环总数 smarty中的循环-section123456&#123;section name='' loop='' start='' step='' max=''&#125;&#123;/section&#125;&lt;!-- 用法 --&gt;&lt;&#123;section name=i loop=$arr&#125;&gt; &lt;&#123;$arr[i]&#125;&gt;&lt;&#123;/section&#125;&gt; 语法说明 name:循环索引(必须) loop:循环数组(必须) start:初始索引 step:循环增长值 max:最大循环次数 smarty中的判断语句-if语句1234567&#123;if 条件1&#125; //code&#123;elseif 条件2&#125; //code&#123;else&#125; //code&#123;/if&#125; smarty中的变量调节器 语法 1&#123;$var|调节器1:参数1:参数2:参数n|调节器2|...&#125; 语法说明 $var` 要修饰的变量 | 分割调节器函数 : 分割调节器函数的参数 PHP查找替换:str_replace(目标,结果,原始变量) {str_replace(&#39;Itcast&#39;,&#39;传智播客&#39;,$title)} smarty变量调节器替换 {$title|replace:’Itcast’:’传智播客’} 常用变量调节器 date_format 1234当前时间戳:&lt;&#123;time()&#125;&gt;当前时间戳:&lt;&#123;$smarty.now&#125;&gt;格式化时间戳:&lt;&#123;date( 'Y-m-d H:i:s',time())&#125;&gt;格式化时间戳: &lt;&#123;$smarty.now|date_format: '%Y-%m-%d %H:%M:%S'&#125;&gt;]]></content>
      <tags>
        <tag>PHP</tag>
        <tag>SMARTY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[PHP]-PDO]]></title>
    <url>%2F2019%2F03%2F30%2Fphp-pdo%2F</url>
    <content type="text"><![CDATA[PDO简介 PDO: php data object 主要功能: 代替数据库操作类 PDO连接mysql 语法: 1234567PDO::_construct(string $dsn[,string $username[,string $password]])$dsn = "mysql:host=127.0.0.1;port=3306;dbname=pdo_test";$username = 'root';$password = "root";$pdo = new PDO($dsn, $username, $password); PDO常用方法 exec() 执行一条sql语句,返回受影响的行数 query() 执行select,show语句,并返回一个结果集对象(PDOStatement) lastInsertId() 获取插入的记录的ID值 setAttribute() 设置属性 语法:bool PDO::setAttribute(int $attribute,mixed $value) PDOStatement结果集对象常用方法: fetch() 获取结果集的一条记录,指针自动跳转mixed PDOStatement::fetch([int $fetch_style]) fetchAll() 获取结果集的多条记录 fetchColumn() 返回结果集的单独一列,默认为0 rowCount() 返回受上一个sql语句影响的行数 常用foreach遍历 123foreach($PDOStatement as $arr)&#123; print_r($arr);&#125; PDO错误处理模式 错误处理概述 静默模式:不显示任何错误(默认) 警告模式:用PHP的错误等级来报告信息 异常模式:先抛出异常,再处理异常 静默模式 获取错误信息函数 PDO:errorCode(); 获取状态错误码.[00000]正常 PDO:errorInfo(); 获取错误信息 警告模式 必须先设置错误报告模式(在网页直接显示错误或者警告信息) $pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_WARNING); 异常模式 123456789$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);try&#123; //要执行的sql语句&#125;catch(PDOException $e)&#123; ehco "错误行号:".$e-&gt;getLine(); ehco "&lt;br&gt;错误文件:".$e-&gt;getFile(); ehco "&lt;br&gt;错误状态码:".$e-&gt;getCode(); ehco "&lt;br&gt;错误信息:".$e-&gt;getMessage();&#125; PDO预处理模式 sql语句的执行(编译和执行) 如果是第一次执行,先编译后执行,切编译过程非常复杂 如果是第二次执行(相同sql语句),直接从缓存中读取,效率高,安全,有效防止sql语句注入. 预处理步骤 先提取相同结构语句 编译结构,保存结果 再将不同数据部分替换 执行预处理语句 1234567891011121314//(1)使用占位符":value"来代替真正的数据 $sql = "INSERT INTO user(username,password) VALUES(:username,:password)"; $sql = "INSERT INTO user(username,password) VALUES(?,?)";//(2)预编译相同结构的sql语句,返回结果集对象$PDOStatement = $pdo-&gt;prepare($sql);//(3)给占位符绑定真正的数据$PDOStatement-&gt;bindValue(":username","henry");$PDOStatement-&gt;bindValue(":password","566");$PDOStatement-&gt;bindValue("1","henry");$PDOStatement-&gt;bindValue("2","566");//(4)执行预编译sql语句$PDOStatement-&gt;execute();]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[CSS]-高度坍塌问题]]></title>
    <url>%2F2019%2F03%2F29%2FCSS-%E9%AB%98%E5%BA%A6%E5%9D%8D%E5%A1%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[浮动塌陷如果父元素只包含浮动元素,且未设置高度,那么它的高度将坍塌为0.因为浮动元素脱离了文档流,包含他们的父块没有内容,发生塌陷. 解决方案 使用clear属性的空元素 1&lt;div style="clear:both"&gt;&lt;/div&gt; 使用css的overflow属性 给浮动元素的容器添加: 1overflow:hidden||auto; 给浮动元素的容器添加浮动 使用css的:after伪元素(推荐使用) 123.cf:after &#123; clear: both;&#125;]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ES6]-let&const]]></title>
    <url>%2F2019%2F03%2F29%2FES6-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[let let类似于var,但是声明的变量只在该代码块有效 不存在变量提升 暂时性死区 使用let声明变量之前,该变量不可使用 不允许重复声明 块级作用域 块级作用域的出现取代了立即执行函数. 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 块级作用域可以多层嵌套 不建议在块级作用域声明函数,如果需要,也应该使用函数表达式 const const声明一个只读的常量,一旦声明,无法改变.因此声明的同时必须立即赋值. 存在暂时性死区 不可重复声明]]></content>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
</search>
